This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-05T18:11:55.557Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/
  workflows/
    update-twitter-metrics.yml
public/
  favicon.svg
scripts/
  metrics/
    scraper.ts
    test-api.ts
    test.ts
    twitter-api-client.ts
    twitter-config.ts
    types.ts
  update-twitter-metrics.ts
src/
  components/
    astro/
      Breadcrumb.astro
      Footer.astro
      Header.astro
      LanguagePicker.astro
      Newsletter.astro
      seo.astro
    react/
      NewsletterForm.tsx
      Toast.tsx
    tools/
      FilterSelect.astro
      ToolCard.astro
      ToolMetrics.astro
  content/
    home/
      en.json
      pl.json
    tools/
      dex/
        jupiter.mdx
      marketplaces/
        opensea.mdx
      wallets/
        unisat.mdx
    ui/
      en.json
      pl.json
    config.ts
  i18n/
    i18n-config.ts
    utils.ts
  layouts/
    BaseLayout.astro
  pages/
    [lang]/
      tools/
        [...slug].astro
        index.astro
    api/
      subscribe.ts
    pl/
      index.astro
    debug-routes.astro
    debug.astro
    index.astro
.gitignore
astro-mentor-prompt.md
astro.config.mjs
package.json
README.md
tailwind.config.mjs
tools-directory-strategy.md
tsconfig.json
vercel.json
x-metrics-strategy.md

================================================================
Files
================================================================

================
File: .github/workflows/update-twitter-metrics.yml
================
# .github/workflows/update-twitter-metrics.yml
name: Update Twitter Metrics

on:
  schedule:
    - cron: "0 */6 * * *" # Note the correct cron syntax here
  workflow_dispatch:

jobs:
  update-metrics:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm install

      - name: Run update script
        run: npx tsx scripts/update-twitter-metrics.ts

================
File: public/favicon.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 128 128">
    <path d="M50.4 78.5a75.1 75.1 0 0 0-28.5 6.9l24.2-65.7c.7-2 1.9-3.2 3.4-3.2h29c1.5 0 2.7 1.2 3.4 3.2l24.2 65.7s-11.6-7-28.5-7L67 45.5c-.4-1.7-1.6-2.8-2.9-2.8-1.3 0-2.5 1.1-2.9 2.7L50.4 78.5Zm-1.1 28.2Zm-4.2-20.2c-2 6.6-.6 15.8 4.2 20.2a17.5 17.5 0 0 1 .2-.7 5.5 5.5 0 0 1 5.7-4.5c2.8.1 4.3 1.5 4.7 4.7.2 1.1.2 2.3.2 3.5v.4c0 2.7.7 5.2 2.2 7.4a13 13 0 0 0 5.7 4.9v-.3l-.2-.3c-1.8-5.6-.5-9.5 4.4-12.8l1.5-1a73 73 0 0 0 3.2-2.2 16 16 0 0 0 6.8-11.4c.3-2 .1-4-.6-6l-.8.6-1.6 1a37 37 0 0 1-22.4 2.7c-5-.7-9.7-2-13.2-6.2Z" />
    <style>
        path { fill: #000; }
        @media (prefers-color-scheme: dark) {
            path { fill: #FFF; }
        }
    </style>
</svg>

================
File: scripts/metrics/scraper.ts
================
import { chromium, type Page, type BrowserContext } from 'playwright';
import type { TwitterMetrics, ScraperConfig } from './types';
import { ScraperError, ScraperErrorType } from './types';

/**
 * Default configuration for the Twitter scraper
 */
const DEFAULT_CONFIG: ScraperConfig = {
  maxRetries: 3,
  retryDelay: 1000,
  timeout: 30000,
  tweetsToAnalyze: 5,  // Only look at 5 most recent tweets
  userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
};

/**
 * Simplified TwitterScraper that focuses on basic metrics
 */
export class TwitterScraper {
  private config: ScraperConfig;

  constructor(config: Partial<ScraperConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Scrape basic metrics for a Twitter handle
   * Includes retry logic for reliability
   */
  async scrapeMetrics(handle: string): Promise<TwitterMetrics> {
    let lastError: Error | null = null;

    // Try a few times in case of temporary issues
    for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {
      try {
        return await this.singleScrapeAttempt(handle);
      } catch (error) {
        lastError = error as Error;
        console.warn(`Attempt ${attempt} failed for @${handle}:`, error.message);
        
        // Wait before retrying, longer each time
        if (attempt < this.config.maxRetries) {
          await new Promise(resolve => setTimeout(resolve, this.config.retryDelay * attempt));
        }
      }
    }

    throw new ScraperError(
      ScraperErrorType.UNKNOWN,
      `Failed to scrape @${handle} after ${this.config.maxRetries} attempts: ${lastError?.message}`,
      handle
    );
  }

  /**
   * Single attempt to scrape metrics from a profile
   */
  private async singleScrapeAttempt(handle: string): Promise<TwitterMetrics> {
    console.log(`Debug: Launching browser for ${handle}`);
    const browser = await chromium.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    try {
      const context: BrowserContext = await browser.newContext({
        userAgent: this.config.userAgent,
        viewport: { width: 1280, height: 800 }
      });
      
      const page: Page = await context.newPage();
      
      // Set timeout for all operations
      page.setDefaultTimeout(this.config.timeout);

      // Go to profile and wait for key elements
      await page.goto(`https://twitter.com/${handle}`);
      await page.waitForLoadState('networkidle');

      // Check if profile exists
      const notFound = await page.locator('text="This account doesn\'t exist"').count();
      if (notFound > 0) {
        throw new ScraperError(ScraperErrorType.NOT_FOUND, `Twitter handle @${handle} not found`, handle);
      }

      // Get basic profile metrics
      const followers = await this.getFollowers(page);
      const [recentTweets, lastTweetDate] = await this.analyzeTweets(page);

      return {
        handle,
        followers,
        recentTweets,
        lastTweetDate,
        lastUpdate: new Date()
      };
    } finally {
      await browser.close();
    }
  }

  /**
   * Extract followers count from profile
   */
  private async getFollowers(page: Page): Promise<number> {
    try {
      // Wait for followers element to be visible
      await page.waitForSelector('div:has-text("Followers")', { timeout: this.config.timeout });

      // Get the text content of the element containing followers count
      // Note: The span before "Followers" contains the number
      const statsText = await page.evaluate(() => {
        const stats = document.querySelectorAll('span');
        for (const stat of stats) {
          const next = stat.nextElementSibling;
          if (next?.textContent?.trim() === 'Followers') {
            return stat.textContent || '';
          }
        }
        return '';
      });

      if (!statsText) {
        throw new Error('Followers count not found');
      }

      return this.parseMetricText(statsText);
    } catch (error) {
      console.error('Error getting followers:', error);
      throw new ScraperError(
        ScraperErrorType.PARSING,
        'Could not find followers count',
        await page.url()
      );
    }
  }

  /**
   * Analyze recent tweets for engagement metrics
   * Returns [engagement metrics, date of most recent tweet]
   */
  private async analyzeTweets(page: Page): Promise<[TwitterMetrics['recentTweets'], Date]> {
    // Get recent tweets
    const tweets = await page
      .locator('article[data-testid="tweet"]')
      .all();
    
    // Limit to configured number of tweets
    const tweetsToAnalyze = tweets.slice(0, this.config.tweetsToAnalyze);
    
    if (tweetsToAnalyze.length === 0) {
      throw new ScraperError(
        ScraperErrorType.PARSING,
        'No tweets found',
        await page.url()
      );
    }

    // Get timestamp from first (most recent) tweet, being more specific about the time element
    const timestamp = await tweetsToAnalyze[0]
      .locator('time[datetime]')
      .first()
      .getAttribute('datetime');
    
    // Calculate engagement metrics
    let totalLikes = 0;
    let totalRetweets = 0;

    for (const tweet of tweetsToAnalyze) {
      const likes = await this.parseMetricText(
        await tweet.locator('[data-testid="like"]').innerText()
      );
      const retweets = await this.parseMetricText(
        await tweet.locator('[data-testid="retweet"]').innerText()
      );

      totalLikes += likes;
      totalRetweets += retweets;
    }

    return [
      {
        count: tweetsToAnalyze.length,
        avgLikes: Math.round(totalLikes / tweetsToAnalyze.length),
        avgRetweets: Math.round(totalRetweets / tweetsToAnalyze.length)
      },
      new Date(timestamp || Date.now())  // Fallback to current date if no timestamp
    ];
  }

  /**
   * Convert metric text (like "1.5K") to number
   */
  private parseMetricText(text: string): number {
    const clean = text.toLowerCase().trim();
    if (!clean) return 0;

    const num = parseFloat(clean.replace(/[^0-9.]/g, ''));
    
    if (clean.includes('k')) return num * 1000;
    if (clean.includes('m')) return num * 1000000;
    
    return num;
  }
}

================
File: scripts/metrics/test-api.ts
================
// src/scripts/metrics/test-api.ts
import { config } from 'dotenv';
import { TwitterMetricsClient } from './twitter-api-client';
import path from 'path';

// Load environment variables
const envResult = config({ path: path.resolve(process.cwd(), '.env') });

if (envResult.error) {
  console.error('Error loading .env file:', envResult.error);
  process.exit(1);
}

// Verify bearer token is loaded
if (!process.env.TWITTER_BEARER_TOKEN) {
  console.error('TWITTER_BEARER_TOKEN not found in environment variables');
  console.log('Current env vars:', Object.keys(process.env));
  process.exit(1);
}

async function testTwitterApi() {
  console.log('Bearer token length:', process.env.TWITTER_BEARER_TOKEN?.length || 0);

  const client = new TwitterMetricsClient({
    bearerToken: process.env.TWITTER_BEARER_TOKEN
  });

  try {
    console.log('Fetching metrics...');
    const metrics = await client.getMetrics('JupiterExchange');
    
    console.log('\nSuccessfully fetched metrics:');
    console.log(JSON.stringify(metrics, null, 2));

    return metrics;
  } catch (error) {
    console.error('Error testing Twitter API:', error);
    throw error;
  } finally {
    client.destroy();
  }
}

// Run the test
console.log('Starting Twitter API test with expanded data...');
console.log('Current working directory:', process.cwd());
testTwitterApi()
  .then(() => console.log('\nTest completed successfully!'))
  .catch(error => {
    console.error('\nTest failed:', error);
    process.exit(1);
  });

================
File: scripts/metrics/test.ts
================
import { TwitterScraper } from './scraper';

/**
 * Test script for Twitter metrics scraper
 * Tests scraping with one of our tool's Twitter handles
 */
async function testScraper() {
  // Create scraper instance
  const scraper = new TwitterScraper({
    maxRetries: 2,
    tweetsToAnalyze: 5
  });

  try {
    // Try to scrape metrics for UniSat Wallet (one of our tools)
    console.log('Starting scrape test for @unisat_wallet...');
    
    const metrics = await scraper.scrapeMetrics('unisat_wallet');
    
    console.log('\nScrape successful! Results:');
    console.log(JSON.stringify(metrics, null, 2));
    
    return metrics;
  } catch (error) {
    console.error('\nScrape failed:', error);
    process.exit(1);
  }
}

// Run the test
console.log('Starting scraper test...');
testScraper()
  .then(() => console.log('\nTest completed successfully!'))
  .catch(error => {
    console.error('\nTest failed:', error);
    process.exit(1);
  });

================
File: scripts/metrics/twitter-api-client.ts
================
// src/scripts/metrics/twitter-api-client.ts
import { TwitterApi } from 'twitter-api-v2';
import type { ExtendedTwitterMetrics, TwitterMetrics, TwitterTweetData } from './types';
import { DEFAULT_CONFIG, type TwitterApiConfig, validateConfig } from './twitter-config';

export class TwitterMetricsClient {
  private readonly client: TwitterApi;
  private readonly config: TwitterApiConfig;
  private lastRequestTime: number = 0;
  private requestsThisWindow: number = 0;
  private windowResetTimeout: NodeJS.Timeout | null = null;

  constructor(config: Partial<TwitterApiConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    validateConfig(this.config);
    this.client = new TwitterApi(this.config.bearerToken);
    this.startWindowReset();
  }

  private startWindowReset(): void {
    if (this.windowResetTimeout) {
      clearInterval(this.windowResetTimeout);
    }

    this.windowResetTimeout = setInterval(() => {
      this.requestsThisWindow = 0;
      console.log('Rate limit window reset');
    }, 15 * 60 * 1000);
  }

  private async enforceRateLimit(): Promise<void> {
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequestTime;

    if (timeSinceLastRequest < this.config.rateLimit.minDelayBetweenRequests) {
      const delay = this.config.rateLimit.minDelayBetweenRequests - timeSinceLastRequest;
      await new Promise(resolve => setTimeout(resolve, delay));
    }

    if (this.requestsThisWindow >= this.config.rateLimit.maxRequestsPer15Min) {
      console.log('Rate limit reached, waiting for window reset...');
      await new Promise(resolve => setTimeout(resolve, 60 * 1000));
    }

    this.lastRequestTime = Date.now();
    this.requestsThisWindow++;
  }

  async getMetrics(handle: string): Promise<ExtendedTwitterMetrics> {
    try {
      await this.enforceRateLimit();

      console.log(`Fetching user data for @${handle}...`);

      // Get user data with expanded tweet info
      const user = await this.client.v2.userByUsername(handle, {
        'user.fields': [
          'public_metrics',
          'created_at',
          'most_recent_tweet_id',
          'pinned_tweet_id'
        ] as const,
        expansions: ['most_recent_tweet_id', 'pinned_tweet_id'] as any,
        'tweet.fields': [
          'created_at',
          'public_metrics',
          'text'
        ]
      });

      console.log('Raw API response:', JSON.stringify(user, null, 2));

      if (!user.data) {
        throw new Error(`User @${handle} not found`);
      }

      // Extract included tweets if any
      const tweets = (user.includes?.tweets || []) as TwitterTweetData[];
      const mostRecentTweet = tweets.find(t => t.id === user.data.most_recent_tweet_id);
      const pinnedTweet = tweets.find(t => t.id === user.data.pinned_tweet_id);

      // Calculate recent tweet metrics (if available)
      const recentTweets = {
        count: 1, // We only have the most recent tweet
        avgLikes: mostRecentTweet?.public_metrics.like_count || 0,
        avgRetweets: mostRecentTweet?.public_metrics.retweet_count || 0
      };

      // Maintain backwards compatibility with base TwitterMetrics
      const baseMetrics: TwitterMetrics = {
        handle,
        followers: user.data.public_metrics?.followers_count || 0,
        recentTweets,
        lastTweetDate: mostRecentTweet ? new Date(mostRecentTweet.created_at) : new Date(),
        lastUpdate: new Date()
      };

      // Return extended metrics
      return {
        ...baseMetrics,
        mostRecentTweet: mostRecentTweet ? {
          id: mostRecentTweet.id,
          createdAt: mostRecentTweet.created_at,
          text: mostRecentTweet.text,
          metrics: mostRecentTweet.public_metrics
        } : undefined,
        pinnedTweet: pinnedTweet ? {
          id: pinnedTweet.id,
          createdAt: pinnedTweet.created_at,
          text: pinnedTweet.text,
          metrics: pinnedTweet.public_metrics
        } : undefined,
        monthlyStats: {
          tweets: 0, // We can't get this from single request
          avgLikes: mostRecentTweet?.public_metrics.like_count || 0,
          avgRetweets: mostRecentTweet?.public_metrics.retweet_count || 0,
          avgQuotes: mostRecentTweet?.public_metrics.quote_count || 0,
          followersGrowth: 0 // Would need historical data
        },
        weeklyStats: {
          tweets: 0, // Can't get this from single request
          followersGrowth: 0 // Would need historical data
        }
      };

    } catch (error) {
      console.error(`Error fetching metrics for @${handle}:`, error);
      throw error;
    }
  }

  destroy(): void {
    if (this.windowResetTimeout) {
      clearInterval(this.windowResetTimeout);
    }
  }
}

================
File: scripts/metrics/twitter-config.ts
================
// src/scripts/metrics/twitter-config.ts

/**
 * Configuration types for Twitter API client
 */
export interface TwitterApiConfig {
    /** Bearer token from Twitter API v2 */
    bearerToken: string;
    /** Maximum number of tweets to analyze for metrics */
    tweetsToAnalyze: number;
    /** Rate limiting configuration */
    rateLimit: {
      /** Maximum requests per 15-minute window (Twitter's standard) */
      maxRequestsPer15Min: number;
      /** Minimum delay between requests (in milliseconds) */
      minDelayBetweenRequests: number;
    };
  }
  
  /**
   * Default configuration values
   * Adjust these based on your API access level
   */
  export const DEFAULT_CONFIG: TwitterApiConfig = {
    bearerToken: process.env.TWITTER_BEARER_TOKEN || '',
    tweetsToAnalyze: 5,
    rateLimit: {
      maxRequestsPer15Min: 45, // Keep some buffer from the 50 limit
      minDelayBetweenRequests: 2000, // 2 seconds minimum between requests
    },
  };
  
  /**
   * Validate Twitter API configuration
   * Throws error if required values are missing
   */
  export function validateConfig(config: TwitterApiConfig): void {
    if (!config.bearerToken) {
      throw new Error('Twitter Bearer Token is required but not provided');
    }
  
    if (config.tweetsToAnalyze < 1 || config.tweetsToAnalyze > 100) {
      throw new Error('tweetsToAnalyze must be between 1 and 100');
    }
  }

================
File: scripts/metrics/types.ts
================
// src/scripts/metrics/types.ts

/**
 * Twitter API v2 tweet metrics structure
 * Matches exactly what the API returns
 */
export interface TwitterTweetMetrics {
    retweet_count: number;
    reply_count: number;
    like_count: number;
    quote_count: number;
    impression_count?: number;
  }

  /**
   * Structure for individual tweet data from API
   */
  export interface TwitterTweetData {
    id: string;
    created_at: string;
    text: string;
    public_metrics: TwitterTweetMetrics;
  }

  /**
   * Core metrics interface used across all implementations
   * Both scraper and API client must provide these fields
   */
  export interface TwitterMetrics {
    handle: string;
    followers: number;
    recentTweets: {
      count: number;
      avgLikes: number;
      avgRetweets: number;
    };
    lastTweetDate: Date;
    lastUpdate: Date;
  }
  
  /**
   * Extended metrics available when using Twitter API
   * Optional fields that don't break existing implementations
   */
  export interface ExtendedTwitterMetrics extends TwitterMetrics {
    // Added strictness to tweet data structure
    mostRecentTweet?: {
      id: string;
      createdAt: string;
      text: string;
      metrics: TwitterTweetMetrics;
    };
    pinnedTweet?: {
      id: string;
      createdAt: string;
      text: string;
      metrics: TwitterTweetMetrics;
    };
    monthlyStats: MonthlyStats;
    weeklyStats: WeeklyStats;
  }

  /**
   * Monthly statistics for a Twitter profile
   */
  export interface MonthlyStats {
    tweets: number;
    avgLikes: number;
    avgRetweets: number;
    avgQuotes: number;
    followersGrowth: number;
  }

  /**
   * Weekly statistics for a Twitter profile
   */
  export interface WeeklyStats {
    tweets: number;
    followersGrowth: number;
  }

  /**
   * Configuration for the scraper
   */
  export interface ScraperConfig {
    maxRetries: number;
    retryDelay: number;
    timeout: number;
    tweetsToAnalyze: number;
    userAgent: string;
  }
  
  /**
   * Error types for better error handling
   */
  export enum ScraperErrorType {
    NETWORK = 'network',
    PARSING = 'parsing',
    TIMEOUT = 'timeout',
    NOT_FOUND = 'not_found',
    RATE_LIMIT = 'rate_limit',
    UNKNOWN = 'unknown'
  }
  
  /**
   * Custom error class for scraping errors
   */
  export class ScraperError extends Error {
    constructor(
      public type: ScraperErrorType,
      message: string,
      public readonly handle?: string
    ) {
      super(message);
      this.name = 'ScraperError';
    }
  }

================
File: scripts/update-twitter-metrics.ts
================
import { readFile, writeFile } from 'fs/promises';
import { globby } from 'globby';
import { TwitterScraper } from './metrics/scraper';
import type { TwitterMetrics } from './metrics/types';

/**
 * Updates Twitter metrics in all tool MDX files
 * Runs in GitHub Actions every 6 hours
 */
async function updateMetrics() {
  try {
    console.log('Starting Twitter metrics update...');
    
    // Initialize scraper
    const scraper = new TwitterScraper({
      maxRetries: 3,
      tweetsToAnalyze: 5
    });

    // Find all tool MDX files
    const mdxFiles = await globby('src/content/tools/**/*.mdx');
    console.log(`Found ${mdxFiles.length} tool files`);

    // Process each file
    for (const filePath of mdxFiles) {
      try {
        await processFile(filePath, scraper);
      } catch (error) {
        console.error(`Error processing ${filePath}:`, error);
        // Continue with next file even if one fails
      }
    }

    console.log('Metrics update completed successfully');
  } catch (error) {
    console.error('Error updating metrics:', error);
    process.exit(1);
  }
}

/**
 * Process a single MDX file
 * Extracts Twitter handle, gets new metrics, updates file
 */
async function processFile(filePath: string, scraper: TwitterScraper) {
  console.log(`\nProcessing ${filePath}...`);

  // Read file content
  const content = await readFile(filePath, 'utf-8');

  // Extract Twitter handle from social.x field
  const match = content.match(/x:\s*["']https:\/\/twitter\.com\/([^"']+)["']/);
  if (!match) {
    console.log(`No Twitter handle found in ${filePath}, skipping...`);
    return;
  }

  const handle = match[1];
  console.log(`Found Twitter handle: @${handle}`);

  try {
    // Get fresh metrics
    const metrics = await scraper.scrapeMetrics(handle);
    console.log(`Successfully scraped metrics for @${handle}`);
    
    // Update file content
    const updatedContent = updateFileContent(content, metrics);
    
    // Save changes
    await writeFile(filePath, updatedContent, 'utf-8');
    console.log(`Updated metrics for @${handle}`);
  } catch (error) {
    console.error(`Failed to update metrics for @${handle}:`, error);
  }
}

/**
 * Updates the xMetrics section in MDX frontmatter
 */
function updateFileContent(content: string, metrics: TwitterMetrics): string {
  // Prepare new metrics block
  const metricsBlock = `xMetrics:
  handle: "${metrics.handle}"
  followers: ${metrics.followers}
  monthlyStats:
    tweets: ${metrics.recentTweets.count * 6}  # Estimated from recent tweets
    avgLikes: ${metrics.recentTweets.avgLikes}
    avgRetweets: ${metrics.recentTweets.avgRetweets}
    avgQuotes: 0  # Not currently tracked
    followersGrowth: 0  # Not currently tracked
  weeklyStats:
    tweets: ${metrics.recentTweets.count}
    followersGrowth: 0  # Not currently tracked
  lastTweetDate: ${metrics.lastTweetDate.toISOString()}
  lastMetricsUpdate: ${metrics.lastUpdate.toISOString()}`;

  // Replace existing metrics block or add after frontmatter
  if (content.includes('xMetrics:')) {
    // Replace existing block
    return content.replace(
      /xMetrics:[\s\S]+?(^[a-zA-Z]|---)/m,
      `${metricsBlock}\n\n$1`
    );
  } else {
    // Add new block before first non-frontmatter content
    return content.replace(
      /(^---[\s\S]+?)(^[a-zA-Z]|^---)/m,
      `$1\n${metricsBlock}\n\n$2`
    );
  }
}

// Run the update
updateMetrics().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});

================
File: src/components/astro/Breadcrumb.astro
================
---
// src/components/astro/Breadcrumb.astro
import type { CollectionEntry } from "astro:content";
import { useTranslations } from "@/i18n/utils";

interface Props {
  tool?: CollectionEntry<"tools">;
  lang: string;
}

const { tool, lang } = Astro.props;
const t = await useTranslations(lang as "en" | "pl");

// Build breadcrumb items
const items = [
  { label: "Home", url: `/${lang}` },
  { label: t("tools.title"), url: `/${lang}/tools` },
];

if (tool) {
  items.push({
    label: t(`tools.categories.${tool.data.category}`),
    url: `/${lang}/tools?category=${tool.data.category}`,
  });
  items.push({
    label: tool.data.i18n[lang].title,
    url: null, // Current page
  });
}
---

<nav aria-label="Breadcrumb" class="mb-6 px-4 sm:px-0">
  <ol
    class="flex flex-wrap items-center text-sm text-gray-400"
    itemscope
    itemtype="https://schema.org/BreadcrumbList"
  >
    {
      items.map((item, index) => (
        <li
          itemprop="itemListElement"
          itemscope
          itemtype="https://schema.org/ListItem"
          class="flex items-center"
        >
          {index > 0 && (
            <svg
              class="mx-2 h-4 w-4 flex-shrink-0 text-gray-600"
              viewBox="0 0 16 16"
              fill="none"
              stroke="currentColor"
            >
              <path d="M6 12l4-4-4-4" />
            </svg>
          )}
          {item.url ? (
            <a
              href={item.url}
              itemprop="item"
              class="hover:text-white transition-colors whitespace-nowrap"
            >
              <span itemprop="name">{item.label}</span>
            </a>
          ) : (
            <span itemprop="name" class="truncate max-w-[200px]">
              {item.label}
            </span>
          )}
          <meta itemprop="position" content={`${index + 1}`} />
        </li>
      ))
    }
  </ol>
</nav>

================
File: src/components/astro/Footer.astro
================
---
// src/components/astro/Footer.astro
import { useTranslations } from "../../i18n/utils";
import Newsletter from "./Newsletter.astro";

const t = await useTranslations(Astro.currentLocale as "en" | "pl");
---

<footer class="py-16 border-t border-gray-600">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <div class="mb-12">
      <div class="flex items-center mb-6">
        <span class="text-2xl font-bold">Web3Yoda</span>
      </div>
      <p class="text-gray-400 text-lg">{t("footer.description")}</p>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-12">
      <Newsletter />
    </div>

    <div
      class="flex justify-between items-center pt-8 border-t border-gray-600"
    >
      <p class="text-gray-400 text-sm">{t("copyright")}</p>
      <div class="flex space-x-6">
        <a
          href="https://twitter.com/phantom0fweb3"
          class="text-gray-400 hover:text-white transition-colors"
          aria-label="Twitter"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 16 16"
            fill="currentColor"
            aria-hidden="true"
          >
            <path
              d="M9.18549 7.49741L14.4309 1.39999H13.1879L8.63331 6.6943L4.99554 1.39999H0.799805L6.30082 9.40592L0.799805 15.8H2.04288L6.85269 10.209L10.6944 15.8H14.8902L9.18518 7.49741H9.18549ZM7.48292 9.47645L6.92556 8.67924L2.49078 2.33576H4.40007L7.97899 7.45515L8.53635 8.25236L13.1885 14.9068H11.2792L7.48292 9.47676V9.47645Z"
            ></path>
          </svg>
          <span class="sr-only">Twitter</span>
        </a>
        <a
          href="mailto:web3yoda.xyz@pm.me"
          class="text-gray-400 hover:text-white transition-colors"
          aria-label="Email"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            aria-hidden="true"
          >
            <rect width="20" height="16" x="2" y="4" rx="2"></rect>
            <path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path>
          </svg>
          <span class="sr-only">Email</span>
        </a>
      </div>
    </div>
  </div>
</footer>

================
File: src/components/astro/Header.astro
================
---
// src/components/astro/Header.astro
import LanguagePicker from "./LanguagePicker.astro";
import { useTranslations } from "@/i18n/utils";
import type { SupportedLanguages } from "@/i18n/i18n-config";

const t = await useTranslations(Astro.currentLocale as SupportedLanguages);

const menuIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
</svg>`;

const closeIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
</svg>`;
---

<header
  class="fixed top-0 left-0 right-0 z-50 bg-black/80 backdrop-blur-sm border-b border-gray-800"
>
  <div class="max-w-7xl mx-auto px-4 sm:px-8">
    <div class="flex items-center justify-between h-20">
      <a href="/" class="flex items-center group">
        <svg
          class="w-12 h-12 sm:w-20 sm:h-20 transition-transform duration-300 group-hover:scale-110"
          viewBox="0 0 64 64"
        >
          <rect x="16" y="8" width="32" height="32" fill="#ffffff"></rect>
          <rect x="24" y="16" width="4" height="4" fill="#000000"></rect>
          <rect x="36" y="16" width="4" height="4" fill="#000000"></rect>
          <rect x="24" y="28" width="16" height="4" fill="#000000"></rect>
        </svg>
        <span class="ml-3 text-lg sm:text-xl font-bold">Web3Yoda</span>
      </a>

      <nav class="hidden md:flex items-center space-x-8">
        <a
          href={`/${Astro.currentLocale}/tools`}
          class="text-gray-400 hover:text-white transition-colors"
        >
          {t("tools.title")}
        </a>
        <LanguagePicker />
        <a
          href="https://twitter.com/phantom0fweb3"
          class="text-gray-400 hover:text-white transition-colors duration-300"
          title={t("nav.twitter")}
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 16 16"
            fill="currentColor"
            aria-hidden="true"
          >
            <path
              d="M9.18549 7.49741L14.4309 1.39999H13.1879L8.63331 6.6943L4.99554 1.39999H0.799805L6.30082 9.40592L0.799805 15.8H2.04288L6.85269 10.209L10.6944 15.8H14.8902L9.18518 7.49741H9.18549ZM7.48292 9.47645L6.92556 8.67924L2.49078 2.33576H4.40007L7.97899 7.45515L8.53635 8.25236L13.1885 14.9068H11.2792L7.48292 9.47676V9.47645Z"
            ></path>
          </svg>
          <span class="sr-only">{t("nav.twitter")}</span>
        </a>
      </nav>

      <button
        id="mobile-menu-button"
        class="md:hidden p-2 text-gray-400 hover:text-white"
        aria-label="Toggle menu"
      >
        <span class="menu-open" set:html={menuIcon} />
        <span class="menu-close hidden" set:html={closeIcon} />
      </button>
    </div>

    <div id="mobile-menu" class="md:hidden hidden pb-4" aria-hidden="true">
      <nav class="flex flex-col space-y-4">
        <a
          href={`/${Astro.currentLocale}/tools`}
          class="text-gray-400 hover:text-white transition-colors py-2"
        >
          {t("tools.title")}
        </a>
        <div class="py-2">
          <LanguagePicker />
        </div>
        <a
          href="https://twitter.com/phantom0fweb3"
          class="text-gray-400 hover:text-white transition-colors duration-300 py-2"
        >
          {t("nav.twitter")}
        </a>
      </nav>
    </div>
  </div>
</header>

<div class="h-20"></div>

<script>
  const mobileMenuButton = document.getElementById("mobile-menu-button");
  const mobileMenu = document.getElementById("mobile-menu");
  const menuOpen = document.querySelector(".menu-open");
  const menuClose = document.querySelector(".menu-close");

  if (mobileMenuButton && mobileMenu && menuOpen && menuClose) {
    mobileMenuButton.addEventListener("click", () => {
      const isExpanded =
        mobileMenuButton.getAttribute("aria-expanded") === "true";

      mobileMenuButton.setAttribute("aria-expanded", (!isExpanded).toString());
      mobileMenu.classList.toggle("hidden");
      mobileMenu.setAttribute("aria-hidden", isExpanded.toString());

      menuOpen.classList.toggle("hidden");
      menuClose.classList.toggle("hidden");
    });
  }
</script>

================
File: src/components/astro/LanguagePicker.astro
================
---
// src/components/astro/LanguagePicker.astro
import { languages } from "../../i18n/utils";

// Get current language name for aria-label
const currentLangCode = Astro.currentLocale as keyof typeof languages;
const currentLangName = languages[currentLangCode];
---

<style>
  .custom-select {
    appearance: none;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="gray"><path d="M5.5 8l4.5 4.5L14.5 8H5.5z"/></svg>');
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 16px;
    padding-right: 30px;
  }

  /* Hide label visually while keeping it accessible for screen readers */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
</style>

<div class="language-picker">
  <label for="language-select" class="sr-only">
    Select language - currently {currentLangName}
  </label>
  <select
    id="language-select"
    class="custom-select bg-transparent border border-gray-600 rounded px-3 py-2 text-gray-400 focus:border-white hover:border-gray-400 transition-colors"
    aria-label={`Select language - currently ${currentLangName}`}
    onchange="window.location.pathname = this.value"
  >
    {
      Object.entries(languages).map(([lang, label]) => (
        <option
          value={lang === "en" ? "/" : `/${lang}/`}
          selected={Astro.currentLocale === lang}
        >
          {label}
        </option>
      ))
    }
  </select>
</div>

================
File: src/components/astro/Newsletter.astro
================
---
// src/components/astro/Newsletter.astro
import { useTranslations } from "../../i18n/utils";
import NewsletterForm from "../react/NewsletterForm";
import Toast from "../react/Toast";
import { getCollection } from "astro:content";
import type { CollectionEntry } from "astro:content";

const currentLocale = Astro.currentLocale as "en" | "pl";
const t = await useTranslations(currentLocale);

const translations = {
  title: t("newsletter.title"),
  description: t("newsletter.description"),
  placeholder: t("newsletter.placeholder"),
  button: t("newsletter.button"),
};

// Get UI translations for Toast component
const uiCollections = await getCollection("ui");
const uiTranslations = uiCollections.find(
  (entry) => entry.id === currentLocale
)?.data;

if (!uiTranslations) {
  throw new Error(`No UI translations found for locale: ${currentLocale}`);
}
---

<div class="newsletter-section">
  <NewsletterForm client:load translations={translations} />
  <Toast
    client:load
    data-locale={currentLocale}
    translations={uiTranslations as Record<string, any>}
  />
</div>

================
File: src/components/astro/seo.astro
================
---
// src/components/astro/SEO.astro
interface Props {
  title: string;
  description: string;
  image?: string;
  canonicalUrl?: string;
  type?: string;
  currentLocale: string;
  alternateUrls: {
    [key: string]: string;
  };
  schema?: Record<string, any>; // Allow custom schema override
  meta?: Array<{ name: string; content: string }>; // Additional meta tags
  robots?: string; // Custom robots directive
}

const {
  title,
  description,
  image = "/default-og.png",
  canonicalUrl,
  type = "website",
  currentLocale,
  alternateUrls,
  schema,
  meta = [],
  robots = "index, follow",
} = Astro.props;

// Get the current URL
const currentUrl = Astro.url.href;

// Default schema if none provided
const defaultSchema = {
  "@context": "https://schema.org",
  "@type": "WebSite",
  url: currentUrl,
  name: title,
  description: description,
  inLanguage: currentLocale,
  alternateName: Object.values(alternateUrls),
};

// Merge default schema with provided schema or use default
const finalSchema = schema
  ? { "@context": "https://schema.org", ...schema }
  : defaultSchema;
---

<!-- Basic Meta Tags -->
<title>{title}</title>
<meta name="description" content={description} />
<meta name="robots" content={robots} />
<link rel="canonical" href={canonicalUrl || currentUrl} />

<!-- Custom Meta Tags -->
{meta.map((tag) => <meta name={tag.name} content={tag.content} />)}

<!-- Open Graph / Facebook -->
<meta property="og:type" content={type} />
<meta property="og:url" content={currentUrl} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:image" content={new URL(image, Astro.url)} />
<meta property="og:locale" content={currentLocale} />

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={currentUrl} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={new URL(image, Astro.url)} />

<!-- Language Alternates -->
<link rel="alternate" href={alternateUrls["x-default"]} hreflang="x-default" />
{
  Object.entries(alternateUrls)
    .filter(([lang]) => lang !== "x-default")
    .map(([lang, url]) => <link rel="alternate" href={url} hreflang={lang} />)
}

<!-- JSON-LD Schema -->
<script type="application/ld+json" set:html={JSON.stringify(finalSchema)} />

================
File: src/components/react/NewsletterForm.tsx
================
// src/components/react/NewsletterForm.tsx
import React, { useState } from 'react';
import type { ToastEvent } from './Toast';

interface NewsletterFormProps {
  translations: {
    title: string;
    description: string;
    placeholder: string;
    button: string;
  };
}

const NewsletterForm: React.FC<NewsletterFormProps> = ({ translations }) => {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    const form = e.currentTarget;
    const email = new FormData(form).get('email') as string;

    try {
      const response = await fetch('/api/subscribe', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email })
      });

      const data = await response.json();

      const event = new CustomEvent<ToastEvent['detail']>('show-toast', {
        detail: {
          messageKey: data.success 
            ? 'newsletter.toast.success'
            : data.error === 'Please provide a valid email address'
              ? 'newsletter.toast.error.invalid'
              : data.error === 'Server configuration error'
                ? 'newsletter.toast.error.server'
                : 'newsletter.toast.error.general',
          type: data.success ? 'success' : 'error'
        }
      });
      window.dispatchEvent(event);

      if (data.success) {
        form.reset();
      }
    } catch (error) {
      window.dispatchEvent(new CustomEvent<ToastEvent['detail']>('show-toast', {
        detail: {
          messageKey: 'newsletter.toast.error.general',
          type: 'error'
        }
      }));
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div role="form" aria-labelledby="newsletter-title">
      <h3 id="newsletter-title" className="font-bold mb-4">{translations.title}</h3>
      <p id="newsletter-description" className="text-gray-400 mb-4">{translations.description}</p>

      <form onSubmit={handleSubmit} className="space-y-4">
        <div className="flex gap-2">
          <input
            type="email"
            name="email"
            id="newsletter-email"
            required
            placeholder={translations.placeholder}
            className="flex-1 px-4 py-2 bg-transparent border border-gray-600 rounded-md focus:outline-none focus:border-white"
            disabled={isSubmitting}
            aria-required="true"
            aria-describedby="newsletter-description"
            aria-label={translations.placeholder}
          />
          <button
            type="submit"
            className="px-6 py-2 bg-white text-black font-bold rounded-md hover:bg-gray-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            disabled={isSubmitting}
            aria-live="polite"
          >
            {translations.button}
          </button>
        </div>
      </form>
    </div>
  );
};

export default NewsletterForm;

================
File: src/components/react/Toast.tsx
================
// src/components/react/Toast.tsx
import React, { useEffect, useState } from 'react';
import type { SupportedLanguages } from '@/i18n/i18n-config';

export type ToastType = 'success' | 'error';

export interface ToastEvent {
  detail: {
    messageKey: string;
    type: ToastType;
  }
}

interface ToastProps {
  'data-locale': SupportedLanguages;
  translations: Record<string, any>;
}

const Toast: React.FC<ToastProps> = ({ 'data-locale': locale, translations }) => {
  const [isVisible, setIsVisible] = useState(false);
  const [messageKey, setMessageKey] = useState<string | null>(null);
  const [type, setType] = useState<ToastType>('success');

  useEffect(() => {
    const handleToast = (event: CustomEvent<ToastEvent['detail']>) => {
      setMessageKey(event.detail.messageKey);
      setType(event.detail.type);
      setIsVisible(true);
    };

    window.addEventListener('show-toast', handleToast as EventListener);

    return () => {
      window.removeEventListener('show-toast', handleToast as EventListener);
    };
  }, []);

  useEffect(() => {
    if (isVisible) {
      const timer = setTimeout(() => {
        setIsVisible(false);
      }, 5000);
      return () => clearTimeout(timer);
    }
  }, [isVisible]);

  if (!isVisible || !messageKey || !translations) return null;

  // Get the message from nested keys
  const message = messageKey.split('.').reduce((obj: any, key: string) => obj?.[key], translations);

  return (
    <div className="fixed bottom-4 right-4 z-50 animate-slide-up">
      <div
        className={`flex items-center gap-2 px-4 py-3 rounded-lg shadow-lg ${
          type === 'success' ? 'bg-green-500' : 'bg-red-500'
        }`}
      >
        {type === 'success' ? (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            className="text-white"
          >
            <polyline points="20 6 9 17 4 12" />
          </svg>
        ) : (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            className="text-white"
          >
            <circle cx="12" cy="12" r="10" />
            <line x1="12" y1="8" x2="12" y2="12" />
            <line x1="12" y1="16" x2="12.01" y2="16" />
          </svg>
        )}
        <p className="text-white font-medium">{message}</p>
        <button
          onClick={() => setIsVisible(false)}
          className="ml-4 text-white hover:text-gray-200 transition-colors"
          aria-label="Close notification"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <line x1="18" y1="6" x2="6" y2="18" />
            <line x1="6" y1="6" x2="18" y2="18" />
          </svg>
        </button>
      </div>
    </div>
  );
};

export default Toast;

================
File: src/components/tools/FilterSelect.astro
================
---
// src/components/tools/FilterSelect.astro
interface Props {
  label: string;
  options: Array<{ value: string; label: string }>;
  dataFilter: string;
  className?: string;
}

const { label, options, dataFilter, className = "" } = Astro.props;

// Generate unique ID for accessibility
const uniqueId = `filter-${dataFilter}-${Math.random().toString(36).substr(2, 9)}`;
---

<style>
  .filter-select {
    appearance: none;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="gray"><path d="M5.5 8l4.5 4.5L14.5 8H5.5z"/></svg>');
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 16px;
    padding-right: 30px;
    transition: border-color 0.2s ease;
  }

  .filter-select:hover {
    border-color: rgb(209 213 219);
  }

  /* Hide default arrow in IE/Edge */
  .filter-select::-ms-expand {
    display: none;
  }

  /* Focus styles for keyboard navigation */
  .filter-select:focus {
    outline: 2px solid white;
    outline-offset: 2px;
  }

  /* High contrast mode support */
  @media (forced-colors: active) {
    .filter-select {
      border: 1px solid CanvasText;
    }
    .filter-select:focus {
      outline: 2px solid ButtonText;
    }
  }
</style>

<div
  class={`filter-group ${className}`}
  role="group"
  aria-labelledby={`${uniqueId}-label`}
>
  <label
    id={`${uniqueId}-label`}
    for={uniqueId}
    class="text-sm text-gray-400 block mb-2"
  >
    {label}
  </label>
  <select
    id={uniqueId}
    data-filter={dataFilter}
    class="filter-select w-full bg-transparent border border-gray-600 rounded px-3 py-2 text-gray-400 focus:border-white focus:outline-none"
    aria-label={`Select ${label.toLowerCase()}`}
    aria-describedby={`${uniqueId}-description`}
  >
    {
      options.map(({ value, label: optionLabel }) => (
        <option value={value} aria-selected={value === "all"}>
          {optionLabel}
        </option>
      ))
    }
  </select>
  <span id={`${uniqueId}-description`} class="sr-only">
    Use up and down arrow keys to navigate through options
  </span>
</div>

================
File: src/components/tools/ToolCard.astro
================
---
// src/components/tools/ToolCard.astro
import type { CollectionEntry } from "astro:content";
import { Image } from "astro:assets";
import { useTranslations } from "@/i18n/utils";
import type { Tool } from "@/content/config";

interface Props {
  tool: CollectionEntry<"tools">;
  lang: "en" | "pl";
}

const { tool, lang } = Astro.props;
const t = await useTranslations(lang);

// Get localized content
const localizedContent = tool.data.i18n[lang];

// Ensure localized content exists
if (!localizedContent) {
  throw new Error(`Missing localized content for language: ${lang}`);
}

// Generate tool URL
const toolUrl = `/${lang}/tools/${tool.id.split("/").pop()}`;

// Create tool data for filtering
const toolFilterData = {
  category: tool.data.category,
  ecosystems: tool.data.ecosystems,
  status: tool.data.status,
  pricing: tool.data.metadata?.pricing,
};

// Tailwind classes for consistent styling
const classes = {
  card: "group flex flex-col h-full min-h-[300px] border border-gray-700 rounded-lg p-8 hover:border-gray-500 transition-colors relative bg-gray-900/50 backdrop-blur-sm",
  cardLink: "absolute inset-0 z-0",
  logoContainer: "w-20 h-20 mb-6 transition-transform group-hover:scale-105", // Adjusted size
  logo: "w-full h-full object-contain rounded-lg bg-gray-800 p-2",
  title:
    "text-xl font-bold mb-2 group-hover:text-white transition-colors line-clamp-1",
  description: "text-gray-400 mb-6 line-clamp-2 flex-grow",
  metadataRow: "mt-auto pt-4 border-t border-gray-700",
  metadata: "flex flex-wrap gap-2",
  badge:
    "px-2 py-1 bg-gray-800 rounded text-sm text-gray-300 whitespace-nowrap",
  socialLinks: "flex items-center space-x-2 mt-4 relative z-10", // Higher z-index for clickable social links
  socialLink:
    "text-gray-400 hover:text-white transition-colors p-1 relative z-10 focus:outline-none focus:ring-2 focus:ring-white focus:ring-offset-2 focus:ring-offset-gray-800",
};

// Social media platform labels for accessibility
const platformLabels = {
  github: "GitHub",
  x: "X (Twitter)",
  discord: "Discord",
  telegram: "Telegram",
} as const;
---

<article class="relative" data-tool={JSON.stringify(toolFilterData)}>
  <div class={classes.card}>
    <!-- Make entire card clickable -->
    <a
      href={toolUrl}
      class={classes.cardLink}
      aria-label={`View details for ${localizedContent.title}`}
    >
      <span class="sr-only">View {localizedContent.title}</span>
    </a>

    <!-- Tool Logo -->
    <div class={classes.logoContainer}>
      {
        tool.data.logo ? (
          <Image
            src={tool.data.logo as string}
            alt={`${localizedContent.title} logo`}
            width={64}
            height={64}
            class={classes.logo}
          />
        ) : (
          <div class={`${classes.logo} flex items-center justify-center`}>
            <span class="text-xs text-gray-400">No logo</span>
          </div>
        )
      }
    </div>

    <!-- Tool Info -->
    <h3 class={classes.title}>{localizedContent.title}</h3>
    <p class={classes.description}>{localizedContent.description}</p>

    <!-- Metadata Row -->
    <div class={classes.metadataRow}>
      <div class={classes.metadata}>
        <span class={classes.badge}>
          {t(`tools.status.${tool.data.status}`)}
        </span>
        <span class={classes.badge}>
          {t(`tools.ecosystems.${tool.data.ecosystems[0]}`)}
        </span>
        {
          tool.data.metadata?.pricing && (
            <span class={classes.badge}>
              {t(`tools.pricing.${tool.data.metadata.pricing}`)}
            </span>
          )
        }
      </div>

      <!-- Social Links with Improved Accessibility -->
      <div
        class={classes.socialLinks}
        aria-label={`${localizedContent.title} social links`}
      >
        {
          tool.data.github && (
            <a
              href={tool.data.github}
              target="_blank"
              rel="noopener noreferrer"
              class={classes.socialLink}
              aria-label={`${localizedContent.title} ${platformLabels.github}`}
              onclick="event.stopPropagation()"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                aria-hidden="true"
                role="img"
              >
                <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" />
              </svg>
            </a>
          )
        }

        {
          tool.data.social?.x && (
            <a
              href={tool.data.social.x}
              target="_blank"
              rel="noopener noreferrer"
              class={classes.socialLink}
              aria-label={`${localizedContent.title} ${platformLabels.x}`}
              onclick="event.stopPropagation()"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 16 16"
                fill="currentColor"
                aria-hidden="true"
                role="img"
              >
                <path d="M9.18549 7.49741L14.4309 1.39999H13.1879L8.63331 6.6943L4.99554 1.39999H0.799805L6.30082 9.40592L0.799805 15.8H2.04288L6.85269 10.209L10.6944 15.8H14.8902L9.18518 7.49741H9.18549ZM7.48292 9.47645L6.92556 8.67924L2.49078 2.33576H4.40007L7.97899 7.45515L8.53635 8.25236L13.1885 14.9068H11.2792L7.48292 9.47676V9.47645Z" />
              </svg>
            </a>
          )
        }

        {
          tool.data.social?.discord && (
            <a
              href={tool.data.social.discord}
              target="_blank"
              rel="noopener noreferrer"
              class={classes.socialLink}
              aria-label={`${localizedContent.title} ${platformLabels.discord}`}
              onclick="event.stopPropagation()"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="currentColor"
                aria-hidden="true"
                role="img"
              >
                <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z" />
              </svg>
            </a>
          )
        }

        {
          tool.data.social?.telegram && (
            <a
              href={tool.data.social.telegram}
              target="_blank"
              rel="noopener noreferrer"
              class={classes.socialLink}
              aria-label={`${localizedContent.title} ${platformLabels.telegram}`}
              onclick="event.stopPropagation()"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="20"
                height="20"
                viewBox="0 0 24 24"
                fill="currentColor"
                aria-hidden="true"
                role="img"
              >
                <path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z" />
              </svg>
            </a>
          )
        }
      </div>
    </div>
  </div>
</article>

================
File: src/components/tools/ToolMetrics.astro
================
---
// src/components/tools/ToolMetrics.astro
import type { XMetrics } from "@/content/config";
import { useTranslations } from "@/i18n/utils";
import type { SupportedLanguages } from "@/i18n/i18n-config";

interface Props {
  metrics: XMetrics;
  lang: SupportedLanguages;
}

const { metrics, lang } = Astro.props;
const t = await useTranslations(lang);

// Ensure metrics exist
if (!metrics) return null;

const { followers, monthlyStats } = metrics;

const formatNumber = (num: number): string => {
  if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
  if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
  return num.toString();
};
---

<div class="flex items-center gap-6 mt-4 text-gray-400">
  <h2 class="text-lg font-bold">{t("tools.metrics.sectionTitle")}</h2>

  <div
    class="flex items-center gap-2 hover:text-blue-400 transition-colors"
    title={t("tools.metrics.followers")}
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="20"
      height="20"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <path d="M17 21v-2a4 4 0 0 0-4-4H7a4 4 0 0 0-4 4v2"></path>
      <circle cx="9" cy="7" r="4"></circle>
      <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
      <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
    </svg>
    <span class="text-sm font-medium">{followers}</span>
  </div>

  <div
    class="flex items-center gap-2 hover:text-blue-400 transition-colors"
    title={t("tools.metrics.monthly.engagement")}
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="20"
      height="20"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <path
        d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"
      ></path>
    </svg>
    <span class="text-sm font-medium">{monthlyStats.avgLikes}</span>
  </div>

  <div
    class="flex items-center gap-2 hover:text-green-500 transition-colors"
    title={t("tools.metrics.monthly.engagement")}
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="20"
      height="20"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <path d="M17 1l4 4-4 4"></path>
      <path d="M3 11V9a4 4 0 0 1 4-4h14"></path>
      <path d="M7 23l-4-4 4-4"></path>
      <path d="M21 13v2a4 4 0 0 1-4 4H3"></path>
    </svg>
    <span class="text-sm font-medium">{monthlyStats.avgRetweets}</span>
  </div>
  {
    monthlyStats.followersGrowth > 0 && (
      <div
        class="flex items-center gap-2 text-green-400"
        title={t("tools.metrics.monthly.growth")}
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <path d="m18 15 3-3-3-3" />
          <path d="M3 12h18" />
        </svg>
        <span class="text-sm font-medium">
          +{monthlyStats.followersGrowth}%
        </span>
      </div>
    )
  }
</div>

================
File: src/content/home/en.json
================
{
    "hero": {
      "title": "Your Web3 Onboarding Guides & Tools",
      "subtitle": "Navigate Web3 with our essential toolkit and expert guidance. From wallets and DeFi protocols to NFT marketplaces and cross-chain bridges - we've tested and verified the best Web3 tools to help you explore blockchain technology safely and effectively"
    },
    "catalog": {
      "title": "Web3 Tools Directory",
      "description": "Browse our curated collection of verified Web3 tools",
      "button": "Browse Catalog",
      "benefits": [
        {
          "title": "BTC, ETH, SOL",
          "description": "Cross-chain solutions"
        },
        {
          "title": "Verified Status",
          "description": "Regular updates"
        },
        {
          "title": "Best Free Tools",
          "description": "Start exploring"
        },
        {
          "title": "Web3Yoda verified",
          "description": "Security first"
        }
      ]
    },
    "consultations": {
      "title": "Coaching Sessions",
      "items": [
        {
          "title": "Web3 Basics",
          "description": "All you need to start your transition into Web3"
        },
        {
          "title": "NFT & Digital Collectibles",
          "description": "Deep dive into NFTs, digital collectibles & marketplaces"
        },
        {
          "title": "Multi-Chain Mastery",
          "description": "Advanced guidance on navigating multiple blockchain ecosystems"
        }
      ]
    },
    "services": {
      "title": "Services",
      "items": [
        {
          "title": "Custom Tools Development",
          "description": "Building websites and tools with wallets auth and wallets integrations, workflow automations with AI & AI agents, eg. X (Twitter) bots"
        }
      ]
    },
    "discovery": {
      "title": "Free Discovery Call",
      "description": "15 min call to get to know your personal needs",
      "cta": "Schedule a Call"
    },
    "benefits": {
      "title": "Why Choose Web3Yoda?",
      "items": [
        {
          "title": "Battle-Tested Web Veterans",
          "description": "Ex-Googler (SQE team), Web2/Web3 brands founders & builders, with hands-on experience navigating the evolving Web3 landscape"
        },
        {
          "title": "Real-World Experience",
          "description": "Daily practitioners & builders actively using DeFi, trading crypto, perps, NFTs, ordinals & memecoins. We don't just teach it, We live it"
        },
        {
          "title": "Focused Mastery Path",
          "description": "Tailored guidance focusing on exactly what you need to master - no fluff, just practical Web3 skills"
        }
      ]
    }
  }

================
File: src/content/home/pl.json
================
{
    "hero": {
      "title": "Twój przewodnik i sprawdzone narzędzia Web3",
      "subtitle": "Odkrywaj Web3 z najlepszymi narzędziami i sprawdzonymi rozwiązaniami. Portfele, DeFi, DEXy, Marketplace'y NFT.  Testujemy, weryfikujemy i wybieramy to, co najlepsze, abyś mógł bezpiecznie i skutecznie poruszać się po sieciach blockchain"
    },
    "catalog": {
      "title": "Katalog narzędzi Web3",
      "description": "Starannie wybrane i przetestowane narzędzia Web3",
      "button": "Zobacz Katalog",
      "benefits": [
        {
          "title": "BTC, ETH, SOL",
          "description": "Rozwiązania Cross-chain"
        },
        {
          "title": "Monitorowany status",
          "description": "Regularnie uaktualniamy"
        },
        {
          "title": "Darmowe narzędzia",
          "description": "Zacznij korzystać"
        },
        {
          "title": "Zweryfikowane przez Web3Yoda",
          "description": "Bepieczeńswo jest najważniejsze"
        }
      ]
    },
    "consultations": {
      "title": "Konsultacje",
      "items": [
        {
          "title": "Podstawy Web3",
          "description": "Wszystko, czego potrzebujesz, by przejść gładko z Web2 do Web3 i bezpiecznie się tam poruszać"
        },
        {
          "title": "NFT, ordinals - cyfrowe tokeny kolekcjonerskie",
          "description": "Naucz się kolekcjonować cyfrowe artefakty. Jak, gdzie kupować, sprzedawać i przechowywać tokeny NFT w sieciach ETH, SOL, BTC i innych"
        },
        {
          "title": "Bitcoin, Ethereum, Solana?",
          "description": "Multi-chain w praktyce. Sztuka poruszania się między różnymi sieciami blockchain"
        }
      ]
    },
    "services": {
      "title": "Usługi",
      "items": [
        {
          "title": "Budowa spersonalizowanych narzędzi i automatyzacje",
          "description": "Budowa stron www z integracją portfeli / autoryzacją portfelem, automatyzacje procesów z wykorzystaniem AI, np. boty na platformie X (Twitter)"
        }
      ]
    },
    "discovery": {
      "title": "Darmowa Konsultacja",
      "description": "15-minutowa rozmowa, aby poznać Twoje potrzeby",
      "cta": "Umów Rozmowę"
    },
    "benefits": {
      "title": "Dlaczego Web3Yoda?",
      "items": [
        {
          "title": "Weterani Internetu",
          "description": "W Internecie od samego jego początku, wiemy jak poruszać się w tym ciągle zmieniającym się środowisku. Mamy doświadczenie w tworzeniu, optymalizacji stron i sklepów internetowych oraz aplikacji web'owych, które zdybywaliśmy w wielkich korporacjach, jak Google, ale i w mniejszych startupach"
        },
        {
          "title": "Doświadczenie Web3 z Pierwszej Ręki",
          "description": "Aktywnie poruszamy się na rynkach krypto, NFT, memecoinów i aktywnie udzielamy się w społecznościach w okół wielu projektów Web3"
        },
        {
          "title": "Konsultacje szyte na miarę",
          "description": "Spersonalizowane wskazówki skupiające się dokładnie na tym, czego potrzebujesz - praktyczne umiejętności Web3"
        }
      ]
    }
  }

================
File: src/content/tools/dex/jupiter.mdx
================
---
id: "jupiter-dex"
logo: "../../../assets/tools/jupiter/logo.jpeg"
screenshot: "/src/assets/tools/jupiter/screenshot.png"
website: "https://jup.ag"
github: "https://github.com/jup-ag"
social:
  x: "https://twitter.com/JupiterExchange"
  discord: "https://discord.gg/jup"
category: "defi"
ecosystems: ["solana"]
status: "active"
lastUpdated: 2025-02-03

# X Metrics
xMetrics:
  handle: "JupiterExchange"
  followers: 545200
  monthlyStats:
    tweets: 30  # Estimated from recent tweets
    avgLikes: 693
    avgRetweets: 125
    avgQuotes: 0  # Not currently tracked
    followersGrowth: 0  # Not currently tracked
  weeklyStats:
    tweets: 5
    followersGrowth: 0  # Not currently tracked
  lastTweetDate: 2025-01-30T10:49:54.000Z
  lastMetricsUpdate: 2025-02-04T11:43:07.309Z

metadata:
  tags: ["dex", "aggregator", "solana", "defi", "swap", "perpetuals", "limits"]
  pricing: "free"
i18n:
  en:
    title: "Jupiter"
    description: "The key liquidity aggregator and swap infrastructure for Solana, providing the best token swap rates through smart routing"
    features:
      - "Best execution through smart routing across all Solana DEXes"
      - "Limit orders with no additional fees"
      - "Perpetual futures trading with advanced order types"
    sections:
      - title: "Overview"
        content: "Jupiter is Solana's key liquidity aggregator and infrastructure, serving the majority of Solana's swap volume. It aggregates liquidity from various DEXes and protocols to provide users with the best possible trading rates, while also offering advanced features like limit orders and perpetual futures trading."
      - title: "Technical Infrastructure"
        content: "Built natively on Solana, Jupiter leverages the blockchain's high speed and low costs to deliver optimal swap routes. The platform's smart routing algorithm splits trades across multiple DEXes when necessary to minimize slippage and maximize returns."
    keyFeatures:
      - title: "Swap Aggregation"
        items:
          - "Best price execution across all Solana DEXes"
          - "Smart routing with split trades"
          - "Direct on-chain settlement"
          - "Minimal price impact for large trades"
      - title: "Trading Features"
        items:
          - "Limit orders with no additional fees"
          - "Dollar cost averaging (DCA)"
          - "Real-time price charts"
          - "Token price alerts"
      - title: "Advanced Trading"
        items:
          - "Perpetual futures trading"
          - "Advanced order types"
          - "Position management dashboard"
          - "Cross-margin support"
  pl:
    title: "Jupiter"
    description: "Kluczowy agregator płynności i infrastruktura wymiany na Solanie, zapewniający najlepsze kursy wymiany tokenów poprzez inteligentne trasowanie"
    features:
      - "Najlepsza realizacja poprzez inteligentne trasowanie przez wszystkie DEXy Solany"
      - "Zlecenia limit bez dodatkowych opłat"
      - "Handel kontraktami futures z zaawansowanymi typami zleceń"
    sections:
      - title: "Podstawowe informacje"
        content: "Jupiter jest kluczowym agregatorem płynności i infrastrukturą na Solanie, obsługującym większość wolumenu wymiany Solany. Agreguje płynność z różnych DEXów i protokołów, aby zapewnić użytkownikom najlepsze możliwe kursy handlowe, oferując jednocześnie zaawansowane funkcje jak zlecenia limit i handel kontraktami futures."
      - title: "Infrastruktura Techniczna"
        content: "Zbudowany natywnie na Solanie, Jupiter wykorzystuje wysoką szybkość i niskie koszty blockchainu do dostarczania optymalnych tras wymiany. Algorytm inteligentnego trasowania platformy dzieli transakcje między wiele DEXów, gdy jest to konieczne, aby zminimalizować poślizg i zmaksymalizować zwroty."
    keyFeatures:
      - title: "Agregacja kursów wymian"
        items:
          - "Najlepsza cena wymiany przez analizę wszystkich DEX'ów Solany"
          - "Inteligentne trasowanie z podziałem transakcji"
          - "Bezpośrednie rozliczenie on-chain"
          - "Minimalny wpływ na cenę dla dużych transakcji"
      - title: "Funkcje Handlowe"
        items:
          - "Zlecenia limit bez dodatkowych opłat"
          - "Uśrednianie kosztów w dolarach (DCA)"
          - "Wykresy cen w czasie rzeczywistym"
          - "Alerty cenowe tokenów"
      - title: "Handel Zaawansowany"
        items:
          - "Handel kontraktami futures"
          - "Zaawansowane typy zleceń"
          - "Panel zarządzania pozycjami"
          - "Wsparcie cross-margin"
---

================
File: src/content/tools/marketplaces/opensea.mdx
================
---
id: "opensea-marketplace"
logo: "../../../assets/tools/opensea/logo.png"
screenshot: "/src/assets/tools/opensea/screenshot.png"
website: "https://opensea.io"
github: "https://github.com/ProjectOpenSea"
social:
  x: "https://twitter.com/opensea"
  discord: "https://discord.gg/opensea"
category: "marketplaces"
ecosystems: ["multichain"]
status: "active"
lastUpdated: 2025-01-15

# X Metrics
xMetrics:
  handle: "opensea"
  followers: 2000000
  monthlyStats:
    tweets: 30  # Estimated from recent tweets
    avgLikes: 2602
    avgRetweets: 548
    avgQuotes: 0  # Not currently tracked
    followersGrowth: 0  # Not currently tracked
  weeklyStats:
    tweets: 5
    followersGrowth: 0  # Not currently tracked
  lastTweetDate: 2024-12-20T14:59:20.000Z
  lastMetricsUpdate: 2025-02-04T11:43:14.572Z

metadata:
  tags: ["nft", "marketplace", "ethereum", "seaport", "polygon"]
  pricing: "free"
i18n:
  en:
    title: "OpenSea"
    description: "The world's leading NFT marketplace for discovering, collecting and trading digital collectibles"
    features:
      - "Trade NFTs across multiple blockchains including Ethereum, and Polygon"
      - "Advanced creator tools with royalty support and collection management"
      - "Secure trading infrastructure with Seaport protocol"
    sections:
      - title: "Overview"
        content: "OpenSea is the largest NFT marketplace, providing a secure platform for discovering, buying, and selling digital collectibles. It supports multiple blockchains and offers comprehensive tools for both collectors and creators, making it a central hub in the NFT ecosystem."
      - title: "Trading Infrastructure"
        content: "Built on the Seaport protocol, OpenSea offers gas-optimized transactions, collection offers, trait offers, and bulk listing capabilities. The platform ensures secure trading with features like authenticity verification and automated royalty payments."
    keyFeatures:
      - title: "Multi-Chain Support"
        items:
          - "Ethereum mainnet integration"
          - "Layer 2 support via Polygon"
      - title: "Creator Tools"
        items:
          - "Collection management dashboard"
          - "Customizable royalty settings"
          - "Bulk minting capabilities"
          - "Verified creator program"
      - title: "Trading Features"
        items:
          - "Real-time price tracking"
          - "Collection and trait-based offers"
          - "Bulk listing and delisting"
          - "Automated royalty distribution"
  pl:
    title: "OpenSea"
    description: "Wiodąca platforma NFT do przeglądania, kolekcjonowania i handlu tokenami NFT"
    features:
      - "Handel NFT na wielu blockchainach, w tym Ethereum i Polygon"
      - "Zaawansowane narzędzia dla twórców z obsługą tantiem i zarządzaniem kolekcjami"
      - "Bezpieczna infrastruktura handlowa oparta o protokół Seaport"
    sections:
      - title: "Podstawowe informacje"
        content: "OpenSea jest największym marketplace NFT, zapewniającym bezpieczną platformę do przeglądania i handlu tokenami NFT. Wspiera wiele blockchainów i oferuje kompleksowe narzędzia zarówno dla kolekcjonerów jak i twórców, stanowiąc centralne miejsce w ekosystemie NFT."
      - title: "Infrastruktura"
        content: "Zbudowany na protokole Seaport, OpenSea oferuje zoptymalizowane pod kątem gazu transakcje, oferty dla kolekcji, oferty oparte na cechach i możliwości masowego wystawiania ofert. Platforma zapewnia bezpieczny handel z funkcjami takimi jak weryfikacja autentyczności i automatyczne płatności tantiem."
    keyFeatures:
      - title: "Obsługa Wielu Blockchain'ów"
        items:
          - "Integracja z siecią główną Ethereum"
          - "Wsparcie L2 przez Polygon"
      - title: "Narzędzia dla Twórców"
        items:
          - "Panel zarządzania kolekcjami"
          - "Konfigurowalne ustawienia tantiem"
          - "Możliwości masowego mintowania"
          - "Program dla zweryfikowanych twórców"
      - title: "Funkcje Handlowe"
        items:
          - "Śledzenie cen w czasie rzeczywistym"
          - "Oferty dla kolekcji i cech"
          - "Masowe wystawianie i wycofywanie ofert"
          - "Automatyczna dystrybucja tantiem"
---

================
File: src/content/tools/wallets/unisat.mdx
================
---
id: "unisat-wallet"
logo: "../../../assets/tools/unisat/logo.webp"
screenshot: "/src/assets/tools/unisat/screenshot.png"
website: "https://unisat.io"
github: "https://github.com/unisat-wallet"
social:
  x: "https://twitter.com/unisat_wallet"
  discord: "https://discord.gg/unisat"
category: "wallets"
ecosystems: ["bitcoin"]
status: "active"
lastUpdated: 2025-02-04

# X Metrics
xMetrics:
  handle: "unisat_wallet"
  followers: 236700
  monthlyStats:
    tweets: 30  # Estimated from recent tweets
    avgLikes: 78
    avgRetweets: 21
    avgQuotes: 0  # Not currently tracked
    followersGrowth: 0  # Not currently tracked
  weeklyStats:
    tweets: 5
    followersGrowth: 0  # Not currently tracked
  lastTweetDate: 2025-02-03T06:00:03.000Z
  lastMetricsUpdate: 2025-02-04T11:43:21.443Z

metadata:
  tags: ["bitcoin", "ordinals", "brc20", "wallet", "inscriptions"]
  pricing: "free"
i18n:
  en:
    title: "UniSat Wallet"
    description: "Self-custodial browser extension wallet for Bitcoin, Ordinals, and BRC-20 tokens"
    features:
      - "Complete Bitcoin transaction support with custom fee settings"
      - "Full Ordinals inscription viewer and transfer capabilities"
      - "BRC-20 token management with built-in marketplace integration"
    sections:
      - title: "Overview"
        content: "UniSat Wallet represents the evolution of Bitcoin wallets, bridging traditional Bitcoin functionality with emerging digital asset standards. As a browser extension, it provides seamless access to the Bitcoin network while supporting modern features like Ordinals and BRC-20 tokens."
      - title: "Security Model"
        content: "Your private keys never leave your device. The wallet supports both legacy and modern Bitcoin address formats, ensuring broad compatibility while maintaining robust security standards."
    keyFeatures:
      - title: "Bitcoin Operations"
        items:
          - "Standard BTC transactions with RBF support"
          - "Multiple address formats (Legacy, Native SegWit, Taproot)"
          - "Custom fee settings with fee estimation"
          - "UTXO management and coin control"
      - title: "Ordinals Support"
        items:
          - "View and transfer inscriptions"
          - "Built-in inscription marketplace"
          - "Bulk inscription operations"
          - "Ordinals-aware UTXO management"
      - title: "BRC-20 Integration"
        items:
          - "Token balances and transfers"
          - "Market price tracking"
          - "Trading interface"
          - "Token minting support"
  pl:
    title: "Portfel UniSat"
    description: "Portfel w formie rozszerzenia przeglądarki dla Bitcoin, Ordinals i tokenów BRC-20"
    features:
      - "Pełna obsługa transakcji Bitcoin z możliwością dostosowania opłat"
      - "Pełna obsługa inskrypcji Ordinals z przeglądarką"
      - "Zarządzanie tokenami BRC-20 z wbudowaną integracją giełdy"
    sections:
      - title: "Podstawowe informacje"
        content: "Portfel UniSat reprezentuje ewolucję portfeli Bitcoin, łącząc tradycyjną funkcjonalność Bitcoina z nowymi standardami aktywów cyfrowych. Jako rozszerzenie przeglądarki zapewnia płynny dostęp do sieci Bitcoin, wspierając jednocześnie nowoczesne funkcje jak Ordinals i tokeny BRC-20."
      - title: "Model Bezpieczeństwa"
        content: "Twoje klucze prywatne nigdy nie opuszczają urządzenia. Portfel obsługuje zarówno starsze, jak i nowoczesne formaty adresów Bitcoin, zapewniając szeroką kompatybilność przy zachowaniu wysokich standardów bezpieczeństwa."
    keyFeatures:
      - title: "Operacje Bitcoin"
        items:
          - "Standardowe transakcje BTC ze wsparciem RBF"
          - "Wiele formatów adresów (Legacy, Native SegWit, Taproot)"
          - "Niestandardowe ustawienia opłat z estymacją"
          - "Zarządzanie UTXO"
      - title: "Wsparcie dla Ordinals"
        items:
          - "Przeglądanie i transfer inskrypcji"
          - "Wbudowana giełda inskrypcji"
          - "Operacje masowe na inskrypcjach"
          - "Zarządzanie UTXO z uwzględnieniem Ordinals"
      - title: "Integracja BRC-20"
        items:
          - "Saldo i transfery tokenów"
          - "Śledzenie cen rynkowych"
          - "Interfejs handlowy"
          - "Wsparcie dla mintowania tokenów"
---

================
File: src/content/ui/en.json
================
{
  "id": "en",
  "meta": {
    "description": "Start your Web3 journey with a seasoned guide. Expert consultations and practical knowledge for Web3 transition."
  },
  "nav": {
    "schedule": "Schedule a Call",
    "twitter": "X (Twitter)"
  },
  "newsletter": {
    "title": "Newsletter",
    "description": "Get the latest Web3 insights delivered to your inbox",
    "placeholder": "Enter your email",
    "button": "Subscribe",
    "toast": {
      "success": "Thanks for subscribing!",
      "error": {
        "invalid": "Please provide a valid email address",
        "failed": "Failed to subscribe. Please try again.",
        "server": "Server configuration error",
        "general": "Something went wrong. Please try again."
      }
    }
  },
  "tools": {
    "website": "visit website",
    "total_count": "curated tools",
    "key_features": "Key Features",
    "last_updated": "Last Updated",
    "title": "Web3 Tools Directory",
    "description": "Curated catalog of tools to navigate web3",
    "categories": {
      "wallets": "Wallets",
      "marketplaces": "Marketplaces",
      "defi": "DeFi",
      "analytics": "Analytics",
      "security": "Security",
      "infrastructure": "Infrastructure",
      "development": "Development",
      "identity": "Identity",
      "governance": "Governance",
      "social": "Social",
      "storage": "Storage",
      "gaming": "Gaming",
      "oracles": "Oracles",
      "bridges": "Bridges",
      "data": "Data",
      "other": "Other"
    },
    "ecosystems": {
      "bitcoin": "Bitcoin",
      "ethereum": "Ethereum",
      "solana": "Solana",
      "polkadot": "Polkadot",
      "cosmos": "Cosmos",
      "multichain": "Multichain",
      "other": "Other"
    },
    "status": {
      "active": "Active",
      "beta": "Beta",
      "deprecated": "Deprecated"
    },
    "filters": {
      "all": "All Tools",
      "category": "Category",
      "ecosystem": "Ecosystem",
      "status": "Status"
    },
    "pricing": {
      "free": "Free",
      "paid": "Paid",
      "hybrid": "Hybrid",
      "contact": "Contact for Pricing"
    },
    "metrics": {
      "sectionTitle": "Social metrics:",
      "description": "Live metrics from X (Twitter)",
      "followers": "Followers",
      "monthly": {
        "tweets": "Monthly Tweets",
        "engagement": "Avg Engagement",
        "growth": "Monthly Growth"
      },
      "weekly": {
        "tweets": "Weekly Tweets",
        "growth": "Weekly Growth"
      },
      "lastUpdate": "Metrics Updated",
      "lastTweet": "Last Tweet"
    }
  },
  "footer": {
    "description": "Bridging the gap between Web2 and Web3 through expert guidance and education."
  },
  "copyright": "© 2025 Web3Yoda. All rights reserved."
}

================
File: src/content/ui/pl.json
================
{
  "id": "pl",
  "meta": {
    "description": "Zacznij bezpiecznie korzystać z technologii blockchain. Praktyczna wiedza bez zbędnej teorii"
  },
  "nav": {
    "schedule": "Umów rozmowę",
    "twitter": "X (Twitter)"
  },
  "newsletter": {
    "title": "Newsletter",
    "description": "Otrzymuj najnowsze informacje o Web3 prosto na swoją skrzynkę",
    "placeholder": "Twój email",
    "button": "Subskrybuj",
    "toast": {
      "success": "Dziękujemy za subskrypcję!",
      "error": {
        "invalid": "Podaj prawidłowy adres email",
        "failed": "Nie udało się zapisać. Spróbuj ponownie.",
        "server": "Błąd konfiguracji serwera",
        "general": "Coś poszło nie tak. Spróbuj ponownie."
      }
    }
  },
  "tools": {
    "website": "Strona www",
    "total_count": "sprawdzonych narzędzi",
    "key_features": "Główne Funkcje",
    "last_updated": "Ostatnia Aktualizacja",
    "title": "Katalog Narzędzi Web3",
    "description": "Starannie wyselekcjonowane, sprawdzone narzędzia Web3",
    "categories": {
      "wallets": "Portfele",
      "marketplaces": "Giełdy",
      "defi": "DeFi",
      "analytics": "Analityka",
      "security": "Bezpieczeństwo",
      "infrastructure": "Infrastruktura",
      "development": "Rozwój",
      "identity": "Tożsamość",
      "governance": "Zarządzanie",
      "social": "Social",
      "storage": "Przechowywanie",
      "gaming": "Gry",
      "oracles": "Orakula",
      "bridges": "Mosty",
      "data": "Dane",
      "other": "Inne"
    },
    "ecosystems": {
      "bitcoin": "Bitcoin",
      "ethereum": "Ethereum",
      "solana": "Solana",
      "polkadot": "Polkadot",
      "cosmos": "Cosmos",
      "multichain": "Multichain",
      "other": "Inne"
    },
    "status": {
      "active": "Aktywne",
      "beta": "Beta",
      "deprecated": "Przestarzałe"
    },
    "filters": {
      "all": "Wszystkie",
      "category": "Kategoria",
      "ecosystem": "Ekosystem",
      "status": "Status"
    },
    "pricing": {
      "free": "Darmowe",
      "paid": "Płatne",
      "hybrid": "Hybrydowe",
      "contact": "Skontaktuj się po cenę"
    },
    "metrics": {
      "sectionTitle": "Statystyki SM:",
      "description": "Aktualne metryki z X (Twitter)",
      "followers": "Obserwujący",
      "monthly": {
        "tweets": "Tweety miesięcznie",
        "engagement": "Średnie zaangażowanie",
        "growth": "Wzrost miesięczny"
      },
      "weekly": {
        "tweets": "Tweety tygodniowo",
        "growth": "Wzrost tygodniowy"
      },
      "lastUpdate": "Aktualizacja metryk",
      "lastTweet": "Ostatni Tweet"
    }
  },
  "footer": {
    "description": "Łączymy świat Web2 i Web3 poprzez profesjonalne doradztwo i edukację."
  },
  "copyright": "© 2025 Web3Yoda. Wszelkie prawa zastrzeżone."
}

================
File: src/content/config.ts
================
// src/content/config.ts
import { defineCollection, z } from 'astro:content';
import { glob } from 'astro/loaders';
import { type SupportedLanguages, languages } from '../i18n/i18n-config';


// Create enum values from languages object keys
const languageValues = Object.keys(languages) as [SupportedLanguages, ...SupportedLanguages[]];

// UI collection schema with dynamic language support
const uiSchema = z.object({
  id: z.enum(languageValues),
  meta: z.object({
    description: z.string(),
  }),
  nav: z.object({
    schedule: z.string(),
    twitter: z.string(),
  }),
  newsletter: z.object({
    title: z.string(),
    description: z.string(),
    placeholder: z.string(),
    button: z.string(),
    toast: z.object({
      success: z.string(),
      error: z.object({
        invalid: z.string(),
        failed: z.string(),
        server: z.string(),
        general: z.string(),
      }),
    }),
  }),
  tools: z.object({
    title: z.string(),
    total_count: z.string(),
    description: z.string(),
    website: z.string(),
    key_features: z.string(),
    last_updated: z.string(),
    categories: z.record(z.string()),
    ecosystems: z.record(z.string()),
    status: z.record(z.string()),
    filters: z.record(z.string()),
    pricing: z.record(z.string()),
    metrics: z.object({
      sectionTitle: z.string(),
      description: z.string(),
      followers: z.string(),
      monthly: z.object({
        tweets: z.string(),
        engagement: z.string(),
        growth: z.string()
      }),
      weekly: z.object({
        tweets: z.string(),
        growth: z.string()
      }),
      lastUpdate: z.string(),
      lastTweet: z.string()
    })
  }),
  footer: z.object({
    description: z.string(),
  }),
  copyright: z.string(),
});

// Home collection schema
const homeSchema = z.object({
  hero: z.object({
    title: z.string(),
    subtitle: z.string()
  }),
  catalog: z.object({
    title: z.string(),
    description: z.string(),
    button: z.string(),
    benefits: z.array(z.object({
      title: z.string(),
      description: z.string()
    }))
  }),
  consultations: z.object({
    title: z.string(),
    items: z.array(z.object({
      title: z.string(),
      description: z.string()
    }))
  }),
  services: z.object({
    title: z.string(),
    items: z.array(z.object({
      title: z.string(),
      description: z.string()
    }))
  }),
  discovery: z.object({
    title: z.string(),
    description: z.string(),
    cta: z.string()
  }),
  benefits: z.object({
    title: z.string(),
    items: z.array(z.object({
      title: z.string(),
      description: z.string()
    }))
  })
});

/**
 * X/Twitter Metrics Schema
 * Focuses on recent activity and engagement
 */
const xMetricsSchema = z.object({
  handle: z.string(),
  // Current follower count
  followers: z.number(),

  // Last 30 days activity
  monthlyStats: z.object({
    tweets: z.number(),          // tweets in last 30 days
    avgLikes: z.number(),        // average likes per tweet
    avgRetweets: z.number(),     // average retweets per tweet
    avgQuotes: z.number(),       // average quotes per tweet
    followersGrowth: z.number(), // percentage growth
  }),

  // Last 7 days for more immediate trends
  weeklyStats: z.object({
    tweets: z.number(),          // tweets in last 7 days
    followersGrowth: z.number(), // percentage growth
  }),

  lastTweetDate: z.date(),
  lastMetricsUpdate: z.date(),
}).optional();

/**
 * Core categories for Web3 tools
 */
const categorySchema = z.enum([
  'wallets',         // Crypto wallets, key management
  'marketplaces',    // NFT and token marketplaces
  'defi',           // DeFi protocols and tools
  'infrastructure', // RPCs, nodes, indexers
  'security',       // Security tools, audit tools
  'analytics',      // Data analytics, market tracking
  'other'          // Catch-all for edge cases
]);

/**
 * Tool status indicators
 */
const statusSchema = z.enum([
  'active',     // Tool is actively maintained
  'beta',       // Tool is in testing phase
  'deprecated'  // Tool is no longer maintained
]);

/**
 * Supported blockchain ecosystems
 */
const ecosystemSchema = z.array(z.enum([
  'bitcoin',    // BTC, Ordinals, Lightning
  'ethereum',   // ETH, EVM chains
  'solana',     // SOL ecosystem
  'multichain', // Cross-chain solutions
  'other'       // Other blockchains
])).min(1);

/**
 * Schema for multilingual tool content
 */
const toolTranslationsSchema = z.record(
  z.custom<SupportedLanguages>(),
  z.object({
    title: z.string(),
    description: z.string(),
    features: z.array(z.string()),
    sections: z.array(z.object({
      title: z.string(),
      content: z.string()
    })),
    keyFeatures: z.array(z.object({
      title: z.string(),
      items: z.array(z.string())
    }))
  })
);

/**
 * Main tool schema
 * Combines metadata with translations and X metrics
 */
const toolSchema = z.object({
  id: z.string(),
  logo: z.string().optional(),
  screenshot: z.string().optional(),
  website: z.string().url(),
  github: z.string().url().optional(),
  social: z.object({
    x: z.string().url().optional(),
    discord: z.string().url().optional(),
    telegram: z.string().url().optional(),
  }).optional(),
  category: categorySchema,
  ecosystems: ecosystemSchema,
  status: statusSchema,
  lastUpdated: z.date(),
  xMetrics: xMetricsSchema,
  i18n: toolTranslationsSchema,
  metadata: z.object({
    tags: z.array(z.string()),
    pricing: z.enum(['free', 'paid', 'hybrid'])
  }).optional()
});

// Collections Configuration
const tools = defineCollection({
  schema: ({ image }) => z.object({
    id: z.string(),
    logo: image(),
    cscreenshot: z.string().optional(),
    website: z.string().url(),
    github: z.string().url().optional(),
    social: z.object({
      x: z.string().url().optional(),
      discord: z.string().url().optional(),
      telegram: z.string().url().optional(),
    }).optional(),
    category: categorySchema,
    ecosystems: ecosystemSchema,
    status: statusSchema,
    lastUpdated: z.date(),
    xMetrics: xMetricsSchema,
    i18n: toolTranslationsSchema,
    metadata: z.object({
      tags: z.array(z.string()),
      pricing: z.enum(['free', 'paid', 'hybrid'])
    }).optional()
  }),

  loader: glob({
    pattern: "tools/**/**.mdx",
    base: "./src/content"
  })
});

const home = defineCollection({
  type: 'data',
  schema: homeSchema,
});

const ui = defineCollection({
  type: 'data',
  schema: uiSchema,
});

// Export the collections
export const collections = { tools, home, ui };

// Export type helpers
export type Tool = z.infer<typeof toolSchema>;
export type XMetrics = z.infer<typeof xMetricsSchema>;
export type ToolCategory = z.infer<typeof categorySchema>;
export type ToolStatus = z.infer<typeof statusSchema>;
export type ToolEcosystem = z.infer<typeof ecosystemSchema>[number];

================
File: src/i18n/i18n-config.ts
================
// src/i18n/i18n-config.ts
export const languages = {
    en: 'English',
    pl: 'Polski'
  } as const;
  
  export const defaultLang = 'en';
  export const showDefaultLang = false;
  
  export type SupportedLanguages = keyof typeof languages;

================
File: src/i18n/utils.ts
================
// src/i18n/utils.ts
import { getCollection } from 'astro:content';
import { languages, defaultLang, showDefaultLang, type SupportedLanguages } from './i18n-config';

let cachedUI: Record<string, any> | null = null;

export async function getUI(lang: SupportedLanguages = defaultLang) {
  if (!cachedUI) {
    const uiCollection = await getCollection('ui');
    cachedUI = Object.fromEntries(
      uiCollection.map(entry => [entry.id, entry.data])
    );
  }
  return cachedUI[lang] || cachedUI[defaultLang];
}

export function getLocaleFromUrl(url: URL) {
  const [, lang] = url.pathname.split('/');
  if (lang in languages) return lang as SupportedLanguages;
  return defaultLang;
}

export async function useTranslations(lang: SupportedLanguages) {
  const ui = await getUI(lang);
  return function t(key: string) {
    try {
      const value = key.split('.').reduce((obj, k) => obj?.[k], ui);
      if (value === undefined) {
        console.warn(`Translation missing for key: ${key} in language: ${lang}`);
        // Fall back to default language
        const defaultUI = cachedUI?.[defaultLang];
        return key.split('.').reduce((obj, k) => obj?.[k], defaultUI) || key;
      }
      return value;
    } catch (error) {
      console.error(`Error accessing translation for key: ${key}`, error);
      return key;
    }
  }
}

export function getLocalizedURL(currentPath: string, locale: string, defaultLang: string) {
  // Remove the current locale from the path if it exists
  const pathWithoutLocale = currentPath.replace(/^\/[^/]+\/?/, '');

  // Don't add locale prefix for default language
  if (locale === defaultLang) {
    return pathWithoutLocale || '/';
  }

  // Add the new locale prefix
  return `/${locale}${pathWithoutLocale ? `/${pathWithoutLocale}` : ''}`;
}

export { languages, defaultLang, showDefaultLang };

================
File: src/layouts/BaseLayout.astro
================
---
// src/layouts/BaseLayout.astro
import Analytics from "@vercel/analytics/astro";
import Footer from "../components/astro/Footer.astro";
import Header from "../components/astro/Header.astro";
import SEO from "../components/astro/seo.astro";
import {
  getLocaleFromUrl,
  getLocalizedURL,
  useTranslations,
  languages,
  defaultLang,
} from "../i18n/utils";

interface Props {
  title: string;
  description?: string;
  image?: string;
  type?: string;
  schema?: Record<string, any>;
  meta?: Array<{ name: string; content: string }>;
  robots?: string;
  fullWidth?: boolean;
}

const {
  title,
  description,
  image,
  type,
  schema,
  meta,
  robots,
  fullWidth = false,
} = Astro.props;

const currentLocale = getLocaleFromUrl(Astro.url);
const currentPath = Astro.url.pathname;
const t = await useTranslations(currentLocale);

const siteUrl = Astro.site?.origin || Astro.url.origin;

interface AlternateUrls {
  [key: string]: string;
  "x-default": string;
  en: string;
  pl: string;
}

const baseAlternateUrls = Object.keys(languages).reduce<Record<string, string>>(
  (acc, locale) => {
    const path = getLocalizedURL(currentPath, locale, defaultLang);
    const url = new URL(path, siteUrl).toString();
    return { ...acc, [locale]: url };
  },
  {}
);

const alternateUrlsWithDefault: AlternateUrls = {
  ...baseAlternateUrls,
  "x-default": baseAlternateUrls["en"],
  en: baseAlternateUrls["en"],
  pl: baseAlternateUrls["pl"],
};
---

<!doctype html>
<html lang={currentLocale}>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />

    <SEO
      title={title}
      description={description || t("meta.description")}
      image={image}
      type={type}
      currentLocale={currentLocale}
      alternateUrls={alternateUrlsWithDefault}
      schema={schema}
      meta={meta}
      robots={robots}
    />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body class="bg-black text-white font-mono">
    <div class="flex flex-col min-h-screen">
      {/* Header uses full width */}
      <div class="max-w-7xl w-full mx-auto">
        <Header />
      </div>

      {/* Main content slightly inset */}
      <main
        class={`flex-grow mx-auto w-full px-4 sm:px-6 lg:px-8 py-16 ${
          fullWidth ? "max-w-6xl" : "max-w-4xl"
        }`}
      >
        <slot />
      </main>

      {/* Footer uses full width */}
      <div class="max-w-7xl w-full mx-auto">
        <Footer />
      </div>
      <Analytics />
    </div>
  </body>
</html>

================
File: src/pages/[lang]/tools/[...slug].astro
================
---
// src/pages/[lang]/tools/[...slug].astro
import { type CollectionEntry, getCollection } from "astro:content";
import { Image } from "astro:assets";
import BaseLayout from "@/layouts/BaseLayout.astro";
import { getLocaleFromUrl, useTranslations } from "@/i18n/utils";
import { languages, type SupportedLanguages } from "@/i18n/i18n-config";
import ToolMetrics from "@/components/tools/ToolMetrics.astro";
import Breadcrumb from "@/components/astro/Breadcrumb.astro";

export const prerender = true;

export async function getStaticPaths() {
  const tools = await getCollection("tools");
  return tools.flatMap((tool) => {
    const slug = tool.id.split("/").pop();
    return Object.keys(languages).map((lang) => ({
      params: { lang, slug },
      props: { tool },
    }));
  });
}

const { tool } = Astro.props;
const lang = getLocaleFromUrl(Astro.url) as SupportedLanguages;
const t = await useTranslations(lang);
const localizedContent = tool.data.i18n[lang];

if (!localizedContent) {
  throw new Error(`Missing localized content for language: ${lang}`);
}

const formattedDate = new Intl.DateTimeFormat(lang, {
  year: "numeric",
  month: "long",
  day: "numeric",
}).format(tool.data.lastUpdated);

// Centralized styles using Tailwind classes
const classes = {
  // Tool Header section - full width
  toolheader: "mb-8 md:mb-12 border-b border-gray-700 pb-6 md:pb-8",
  toolheaderContent: "flex flex-col md:flex-row md:items-start gap-6",
  toolmainInfo: "mt-6 md:mt-0 md:flex-grow",

  // Logo styles
  logoContainer: "w-[120px] h-[120px] md:w-[150px] md:h-[150px] flex-shrink-0",
  logo: "w-full h-full object-contain rounded-lg bg-gray-800 p-2",

  // Typography
  title: "text-4xl font-bold mb-4",
  description: "text-xl text-gray-400 mb-6",

  // Metadata and badges
  metadata: "flex flex-wrap gap-4 mb-6",
  badge: "px-3 py-1 bg-gray-800 rounded-full text-sm",

  // Links and buttons
  linksContainer: "flex items-center gap-4",
  websiteLink:
    "px-4 py-2 bg-transparent border border-gray-600 rounded text-gray-300 hover:border-gray-400 hover:text-white transition-colors",
  socialLinks: "flex items-center gap-2",
  socialLink: "text-gray-400 hover:text-white transition-colors p-1",

  // Content sections - narrower width
  content: "w-full max-w-full sm:max-w-4xl mx-auto px-4 sm:px-6 lg:px-8",
  section: "mb-12",
  sectionTitle: "text-2xl font-bold mb-4",
  sectionContent: "text-gray-300 leading-relaxed",

  // Features grid
  featuresGrid: "grid gap-8 md:grid-cols-2 lg:grid-cols-3",
  featureCard:
    "border border-gray-700 rounded-lg p-6 hover:border-gray-500 transition-colors",
  featureTitle: "text-xl font-bold mb-4",
  featureList: "space-y-2 text-gray-300",
  featureItem: "flex items-start gap-2",
  bulletPoint: "text-gray-400 mt-1",

  // Footer
  footer: "mt-16 pt-8 border-t border-gray-700 text-sm text-gray-400",
};

// SEO schema
const toolSchema = {
  "@type": "SoftwareApplication",
  name: localizedContent.title,
  description: localizedContent.description,
  applicationCategory: `Blockchain ${tool.data.category}`,
  operatingSystem: "Web",
  offers: {
    "@type": "Offer",
    price: tool.data.metadata?.pricing === "free" ? "0" : null,
    priceCurrency: "USD",
    availability: "https://schema.org/OnlineOnly",
  },
  featureList: localizedContent.features.join(", "),
  requirements: `Supported blockchains: ${tool.data.ecosystems.join(", ")}`,
  url: tool.data.website,
  dateModified: tool.data.lastUpdated.toISOString(),
  softwareVersion: tool.data.status,
  ...(tool.data.github && {
    codeRepository: tool.data.github,
  }),
};

// Meta tags
const toolMetaTags = [
  {
    name: "keywords",
    content: [
      ...tool.data.ecosystems,
      tool.data.category,
      ...(tool.data.metadata?.tags || []),
      "web3",
      "blockchain",
    ].join(", "),
  },
  {
    name: "application-name",
    content: localizedContent.title,
  },
];
---

<BaseLayout
  title={`${localizedContent.title} - ${t("tools.title")}`}
  description={localizedContent.description}
  schema={toolSchema}
  meta={toolMetaTags}
  robots="index, follow, max-image-preview:large"
  fullWidth={true}
>
  <Breadcrumb tool={tool} lang={lang} />
  {/* Full-width tool header section */}
  <div class={classes.toolheader}>
    <div class={classes.toolheaderContent}>
      <div class={classes.logoContainer}>
        {
          tool.data.logo && (
            <Image
              src={tool.data.logo as string}
              alt={`${localizedContent.title} logo`}
              width={150}
              height={150}
              class={classes.logo}
            />
          )
        }
      </div>

      <div class={classes.toolmainInfo}>
        <h1 class={classes.title}>{localizedContent.title}</h1>
        <p class={classes.description}>{localizedContent.description}</p>

        <div class={classes.metadata}>
          <span class={classes.badge}>
            {t(`tools.status.${tool.data.status}`)}
          </span>
          <span class={classes.badge}>
            {t(`tools.categories.${tool.data.category}`)}
          </span>
          {
            tool.data.metadata?.pricing && (
              <span class={classes.badge}>
                {t(`tools.pricing.${tool.data.metadata.pricing}`)}
              </span>
            )
          }
        </div>

        <div class={classes.linksContainer}>
          <a
            href={tool.data.website}
            target="_blank"
            rel="noopener noreferrer"
            class={classes.websiteLink}
            aria-label={`${t("tools.website")} - ${localizedContent.title}`}
          >
            {t("tools.website")}
          </a>

          <div class={classes.socialLinks}>
            {
              tool.data.github && (
                <a
                  href={tool.data.github}
                  target="_blank"
                  rel="noopener noreferrer"
                  class={classes.socialLink}
                  title="GitHub"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  >
                    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" />
                  </svg>
                </a>
              )
            }

            {
              tool.data.social?.x && (
                <a
                  href={tool.data.social.x}
                  target="_blank"
                  rel="noopener noreferrer"
                  class={classes.socialLink}
                  title="X (Twitter)"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 16 16"
                    fill="currentColor"
                  >
                    <path d="M9.18549 7.49741L14.4309 1.39999H13.1879L8.63331 6.6943L4.99554 1.39999H0.799805L6.30082 9.40592L0.799805 15.8H2.04288L6.85269 10.209L10.6944 15.8H14.8902L9.18518 7.49741H9.18549ZM7.48292 9.47645L6.92556 8.67924L2.49078 2.33576H4.40007L7.97899 7.45515L8.53635 8.25236L13.1885 14.9068H11.2792L7.48292 9.47676V9.47645Z" />
                  </svg>
                </a>
              )
            }

            {
              tool.data.social?.discord && (
                <a
                  href={tool.data.social.discord}
                  target="_blank"
                  rel="noopener noreferrer"
                  class={classes.socialLink}
                  title="Discord"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                  >
                    <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z" />
                  </svg>
                </a>
              )
            }

            {
              tool.data.social?.telegram && (
                <a
                  href={tool.data.social.telegram}
                  target="_blank"
                  rel="noopener noreferrer"
                  class={classes.socialLink}
                  title="Telegram"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                  >
                    <path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z" />
                  </svg>
                </a>
              )
            }
          </div>
        </div>

        {
          tool.data.xMetrics && (
            <ToolMetrics metrics={tool.data.xMetrics} lang={lang} />
          )
        }
      </div>
    </div>
  </div>

  {/* Content sections with narrower width */}
  <div class={classes.content}>
    {/* Tool Sections */}
    {
      localizedContent.sections.map((section) => (
        <section class={classes.section}>
          <h2 class={classes.sectionTitle}>{section.title}</h2>
          <div class={classes.sectionContent}>{section.content}</div>
        </section>
      ))
    }

    {/* Key Features */}
    <section class={classes.section}>
      <h2 class={classes.sectionTitle}>{t("tools.key_features")}</h2>
      <div class={classes.featuresGrid}>
        {
          localizedContent.keyFeatures.map((feature) => (
            <div class={classes.featureCard}>
              <h3 class={classes.featureTitle}>{feature.title}</h3>
              <ul class={classes.featureList}>
                {feature.items.map((item) => (
                  <li class={classes.featureItem}>
                    <span class={classes.bulletPoint}>•</span>
                    <span>{item}</span>
                  </li>
                ))}
              </ul>
            </div>
          ))
        }
      </div>
    </section>

    <footer class={classes.footer}>
      <p>{t("tools.last_updated")}: {formattedDate}</p>
    </footer>
  </div>
</BaseLayout>

================
File: src/pages/[lang]/tools/index.astro
================
---
// src/pages/[lang]/tools/index.astro
/**
 * Tools Directory Index Page
 *
 * This page displays a filterable directory of Web3 tools. It supports:
 * - Internationalization (i18n)
 * - Client-side filtering
 * - Responsive grid layout
 * - Accessibility features
 */

import { type CollectionEntry, getCollection } from "astro:content";
import BaseLayout from "@/layouts/BaseLayout.astro";
import ToolCard from "@/components/tools/ToolCard.astro";
import FilterSelect from "@/components/tools/FilterSelect.astro";
import { getLocaleFromUrl, useTranslations } from "@/i18n/utils";
import { languages, type SupportedLanguages } from "@/i18n/i18n-config";
import { getImage } from "astro:assets";

// Enable static pre-rendering at build time
export const prerender = true;

/**
 * Generate static paths for all supported languages
 */
export function getStaticPaths() {
  return Object.keys(languages).map((lang) => ({
    params: { lang },
  }));
}

// Get current language from URL parameters
const { lang } = Astro.params as { lang: SupportedLanguages };
const t = await useTranslations(lang);

// Fetch all tools from the content collection
let tools: CollectionEntry<"tools">[] = [];
try {
  tools = await getCollection("tools");
} catch (error) {
  console.error("Error fetching tools:", error);
}

// Extract unique values for filter options
const ecosystems = [...new Set(tools.flatMap((tool) => tool.data.ecosystems))];
const categories = [...new Set(tools.map((tool) => tool.data.category))];
const statuses = [...new Set(tools.map((tool) => tool.data.status))];

/**
 * Tailwind classes organized by component
 */
const classes = {
  // Header section
  header: "mb-12 border-b border-gray-700 pb-8",
  title: "text-4xl font-bold mb-6",
  description: "text-xl text-gray-400 max-w-3xl",

  // Stats and metrics
  statsContainer: "mt-4 flex gap-4",
  statsBadge:
    "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-800 text-gray-300",

  // Filters section
  filtersContainer: "mb-12 flex flex-col sm:flex-row gap-4 max-w-4xl",
  filterWrapper: "w-full",

  // Tools grid
  toolsGrid: "grid gap-6 grid-cols-1 md:grid-cols-2 lg:grid-cols-3",
  noTools: "text-center py-12 text-gray-400",
};

/**
 * Filter options configuration
 */
const filterOptions = {
  ecosystem: ecosystems.map((eco) => ({
    value: eco,
    label: t(`tools.ecosystems.${eco}`),
  })),
  category: categories.map((cat) => ({
    value: cat,
    label: t(`tools.categories.${cat}`),
  })),
  status: statuses.map((status) => ({
    value: status,
    label: t(`tools.status.${status}`),
  })),
};

/**
 * SEO Schema for the tools directory
 */
const directorySchema = {
  "@type": "ItemList",
  name: t("tools.title"),
  description: t("tools.description"),
  numberOfItems: tools.length,
  itemListElement: tools.map((tool, index) => ({
    "@type": "ListItem",
    position: index + 1,
    item: {
      "@type": "SoftwareApplication",
      name: tool.data.i18n[lang].title,
      description: tool.data.i18n[lang].description,
      applicationCategory: `Blockchain ${tool.data.category}`,
      url: `${Astro.url.origin}/${lang}/tools/${tool.id.split("/").pop()}`,
    },
  })),
};

const directoryMetaTags = [
  {
    name: "keywords",
    content: [
      "web3 tools",
      "blockchain tools",
      ...new Set(tools.flatMap((tool) => tool.data.ecosystems)),
      ...new Set(tools.map((tool) => tool.data.category)),
    ].join(", "),
  },
];
---

<BaseLayout
  title={t("tools.title")}
  description={t("tools.description")}
  schema={directorySchema}
  meta={directoryMetaTags}
  robots="index, follow, max-image-preview:large"
  fullWidth={true}
>
  {/* Header Section */}
  <div class={classes.header}>
    <h1 class={classes.title}>{t("tools.title")}</h1>
    <p class={classes.description}>{t("tools.description")}</p>

    <div class={classes.statsContainer}>
      <span class={classes.statsBadge}>
        {tools.length}
        {t("tools.total_count")}
      </span>
    </div>
  </div>

  {/* Filters Section */}
  <div class={classes.filtersContainer}>
    <FilterSelect
      label={t("tools.filters.ecosystem")}
      options={[
        { value: "all", label: t("tools.filters.all") },
        ...filterOptions.ecosystem,
      ]}
      dataFilter="ecosystem"
      className={classes.filterWrapper}
    />

    <FilterSelect
      label={t("tools.filters.category")}
      options={[
        { value: "all", label: t("tools.filters.all") },
        ...filterOptions.category,
      ]}
      dataFilter="category"
      className={classes.filterWrapper}
    />

    <FilterSelect
      label={t("tools.filters.status")}
      options={[
        { value: "all", label: t("tools.filters.all") },
        ...filterOptions.status,
      ]}
      dataFilter="status"
      className={classes.filterWrapper}
    />
  </div>

  {/* Tools Grid */}
  {
    tools.length > 0 ? (
      <div class={classes.toolsGrid}>
        {tools.map((tool) => (
          <ToolCard tool={tool} lang={lang} />
        ))}
      </div>
    ) : (
      <p class={classes.noTools}>{t("tools.no_tools_found")}</p>
    )
  }
</BaseLayout>

<script>
  /**
   * Initializes and manages the filtering functionality
   */
  function initializeFilters() {
    const filters = document.querySelectorAll("[data-filter]");
    const toolCards = document.querySelectorAll("[data-tool]");

    // Add change event listeners to all filters
    filters.forEach((filter) => {
      filter.addEventListener("change", updateFilters);
    });

    function updateFilters() {
      // Get current filter values
      const activeFilters = Array.from(filters).reduce(
        (acc, filter) => {
          const value = (filter as HTMLSelectElement).value;
          if (value !== "all") {
            acc[filter.getAttribute("data-filter")!] = value;
          }
          return acc;
        },
        {} as Record<string, string>
      );

      // Update visibility of each tool card
      toolCards.forEach((card) => {
        const toolData = JSON.parse(card.getAttribute("data-tool")!);
        const isVisible = Object.entries(activeFilters).every(
          ([key, value]) => {
            if (key === "ecosystem") {
              return toolData.ecosystems.includes(value);
            }
            return toolData[key] === value;
          }
        );

        card.classList.toggle("hidden", !isVisible);
      });
    }
  }

  // Initialize filters when DOM is ready
  document.addEventListener("DOMContentLoaded", initializeFilters);
</script>

================
File: src/pages/api/subscribe.ts
================
// src/pages/api/subscribe.ts
import type { APIRoute } from 'astro';

export const prerender = false;

function isValidEmail(email: string): boolean {
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  return email.length <= 320 && emailRegex.test(email);
}

export const POST: APIRoute = async ({ request }) => {
  const headers = {
    'Content-Type': 'application/json'
  };

  try {
    // Validate environment variables
    const BEEHIIV_API_KEY = import.meta.env.BEEHIIV_API_KEY;
    const BEEHIIV_PUBLICATION_ID = import.meta.env.BEEHIIV_PUBLICATION_ID;

    if (!BEEHIIV_API_KEY || !BEEHIIV_PUBLICATION_ID) {
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Server configuration error'
        }),
        { status: 500, headers }
      );
    }

    // Parse and validate request
    const body = await request.json();
    const email = body.email?.toString().toLowerCase().trim();

    if (!email || !isValidEmail(email)) {
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Please provide a valid email address'
        }),
        { status: 400, headers }
      );
    }

    // Call Beehiiv API
    const response = await fetch(
      `https://api.beehiiv.com/v2/publications/${BEEHIIV_PUBLICATION_ID}/subscriptions`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${BEEHIIV_API_KEY}`,
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          email,
          reactivate_existing: true,
          send_welcome_email: true,
          utm_source: 'website',
          double_opt_in: false
        })
      }
    );

    const responseData = await response.json();

    if (!response.ok) {
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Failed to subscribe',
          details: responseData
        }),
        { status: response.status, headers }
      );
    }

    return new Response(
      JSON.stringify({
        success: true,
        message: 'Successfully subscribed!'
      }),
      { status: 200, headers }
    );

  } catch (error) {
    console.error('Subscription error:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: 'An unexpected error occurred'
      }),
      { status: 500, headers }
    );
  }
};

================
File: src/pages/pl/index.astro
================
---
// src/pages/pl/index.astro
import BaseLayout from "../../layouts/BaseLayout.astro";
import { getCollection } from "astro:content";

const homeEntries = await getCollection("home");
const content = homeEntries.find((entry) => entry.id.startsWith("pl"))?.data;
const tools = await getCollection("tools");
const toolsCount = tools.length;

if (!content) {
  throw new Error(`No content found for locale: pl`);
}

const styles = {
  section: "mt-16 pt-8 border-t border-gray-600",
  benefitCard: "px-4 py-3 bg-gray-800/50 rounded-lg",
  benefitTitle: "block font-bold mb-1",
  contentBlock:
    "mb-8 transform transition-transform duration-300 ease-in-out hover:translate-x-2",
  title: "text-xl font-bold mb-2",
  description: "text-gray-400",
  cta: "inline-block px-6 py-2 bg-white text-black font-bold rounded-md hover:bg-gray-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed",
};
---

<BaseLayout title={`Web3Yoda - ${content.hero.title}`} fullWidth={true}>
  <div>
    <h1 class="text-4xl font-bold mb-8">{content.hero.title}</h1>
    <p class="text-gray-400 mb-8 text-lg">{content.hero.subtitle}</p>
  </div>

  {/* Tools Directory Feature */}
  <section class="bg-gray-900/50 border border-gray-700 rounded-lg p-8 mb-16">
    <div
      class="flex flex-col md:flex-row items-start md:items-center justify-between gap-6"
    >
      <div>
        <h2 class="text-2xl font-bold mb-2">{content.catalog.title}</h2>
        <p class="text-gray-400 mb-4">
          {content.catalog.description}
        </p>
        <div class="flex items-center space-x-4">
          <a href="/pl/tools" class={styles.cta}>
            {content.catalog.button}
          </a>
          <span
            class="text-sm px-3 py-1 bg-gray-800 rounded-full text-gray-300"
          >
            {toolsCount}
          </span>
        </div>
      </div>
      <div class="grid grid-cols-2 gap-4 text-sm">
        {
          content.catalog.benefits.map((item) => (
            <div class={styles.benefitCard}>
              <h3 class={styles.benefitTitle}>{item.title}</h3>
              <p class={styles.description}>{item.description}</p>
            </div>
          ))
        }
      </div>
    </div>
  </section>

  <section class={styles.section}>
    <h2 class="text-2xl font-bold mb-8">{content.consultations.title}</h2>
    {
      content.consultations.items.map((item) => (
        <div class={styles.contentBlock}>
          <h3 class={styles.title}>{item.title}</h3>
          <p class={styles.description}>{item.description}</p>
        </div>
      ))
    }
  </section>

  <section class={styles.section}>
    <h2 class="text-2xl font-bold mb-8">{content.services.title}</h2>
    {
      content.services.items.map((item) => (
        <div class={styles.contentBlock}>
          <h3 class={styles.title}>{item.title}</h3>
          <p class={styles.description}>{item.description}</p>
        </div>
      ))
    }
  </section>

  <section class={styles.section}>
    <h2 class="text-2xl font-bold mb-8">{content.discovery.title}</h2>
    <div class={styles.contentBlock}>
      <p class={`${styles.description} mb-4`}>
        {content.discovery.description}
      </p>
      <a href="https://cal.com/web3yoda/15min" class={styles.cta}>
        {content.discovery.cta}
      </a>
    </div>
  </section>

  <section class={styles.section}>
    <h2 class="text-2xl font-bold mb-8">{content.benefits.title}</h2>
    <div class="space-y-12">
      {
        content.benefits.items.map((benefit) => (
          <div class={styles.contentBlock}>
            <h3 class={styles.title}>{benefit.title}</h3>
            <p class={styles.description}>{benefit.description}</p>
          </div>
        ))
      }
    </div>
  </section>
</BaseLayout>

================
File: src/pages/debug-routes.astro
================
---
import { getCollection } from "astro:content";
import {
  getLocalizedURL,
  languages,
  defaultLang,
  showDefaultLang,
} from "../i18n/utils"; // Add showDefaultLang import

// Get current URL info
const currentUrl = Astro.url;
const pathname = currentUrl.pathname;

const tools = await getCollection("tools");

// Test various route combinations
const testPaths = ["/tools", "/tools/unisat", "/en/tools", "/en/tools/unisat"];

const routeInfo = testPaths.map((path) => ({
  path,
  localizedURLs: Object.keys(languages).map((lang) => ({
    lang,
    url: getLocalizedURL(path, lang, defaultLang),
  })),
}));

console.log("=== Debug: Current Request ===");
console.log("Current pathname:", pathname);
console.log("Default language:", defaultLang);
console.log("Available languages:", languages);

console.log("=== Debug: Route Generation ===");
console.log("Route Info:", JSON.stringify(routeInfo, null, 2));
---

<h1>Route Debugging Information</h1>

<h2>Current Request</h2>
<pre>
Pathname: {pathname}
Default Language: {defaultLang}
Available Languages: {JSON.stringify(languages, null, 2)}
</pre>

<h2>i18n Configuration</h2>
<pre>
Default Language: {defaultLang}
Show Default Lang Prefix: {showDefaultLang}
</pre>

<h2>Test Routes</h2>
{
  routeInfo.map((info) => (
    <div style="margin-bottom: 2rem; padding: 1rem; border: 1px solid #ccc;">
      <h3>Original Path: {info.path}</h3>
      <ul>
        {info.localizedURLs.map(({ lang, url }) => (
          <li>
            {lang}: {url}
            <a href={url} style="margin-left: 1rem;">
              (Test Link)
            </a>
          </li>
        ))}
      </ul>
    </div>
  ))
}

<h2>Available Tool Routes</h2>
<ul>
  {
    tools.map((tool) => {
      const slug = tool.id.split("/").pop();
      return (
        <li>
          <strong>{tool.id}</strong>
          <ul>
            <li>
              EN: /tools/{slug} <a href={`/tools/${slug}`}>(Test)</a>
            </li>
            <li>
              EN with prefix: /en/tools/{slug}{" "}
              <a href={`/en/tools/${slug}`}>(Test)</a>
            </li>
            <li>
              PL: /pl/tools/{slug} <a href={`/pl/tools/${slug}`}>(Test)</a>
            </li>
          </ul>
        </li>
      );
    })
  }
</ul>

================
File: src/pages/debug.astro
================
---
import { getCollection, type CollectionEntry } from "astro:content";
import type { CollectionKey } from "astro:content";

const homeContent = await getCollection("home" as CollectionKey);
console.log("Collection contents:", homeContent);

const content = homeContent.find((entry) => entry.id === "en.json")?.data;
console.log("Found content:", content);
---

<pre>
  Home Collection: {JSON.stringify(homeContent, null, 2)}
  Found Content: {JSON.stringify(content, null, 2)}
</pre>

================
File: src/pages/index.astro
================
---
// file: src/pages/index.astro
import BaseLayout from "../layouts/BaseLayout.astro";
import { getCollection } from "astro:content";

const homeEntries = await getCollection("home");
const content = homeEntries.find((entry) => entry.id.startsWith("en"))?.data;
const tools = await getCollection("tools");
const toolsCount = tools.length;

if (!content) {
  throw new Error(`No content found for locale: en`);
}

const styles = {
  section: "mt-16 pt-8 border-t border-gray-600",
  benefitCard: "px-4 py-3 bg-gray-800/50 rounded-lg",
  benefitTitle: "block font-bold mb-1",
  contentBlock:
    "mb-8 transform transition-transform duration-300 ease-in-out hover:translate-x-2",
  title: "text-xl font-bold mb-2",
  description: "text-gray-400",
  cta: "inline-block px-6 py-2 bg-white text-black font-bold rounded-md hover:bg-gray-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed",
};
---

<BaseLayout title={`Web3Yoda - ${content.hero.title}`} fullWidth={true}>
  <div>
    <h1 class="text-4xl font-bold mb-8">{content.hero.title}</h1>
    <p class="text-gray-400 mb-8 text-lg">{content.hero.subtitle}</p>
  </div>

  {/* Tools Directory Feature */}
  <section class="bg-gray-900/50 border border-gray-700 rounded-lg p-8 mb-16">
    <div
      class="flex flex-col md:flex-row items-start md:items-center justify-between gap-6"
    >
      <div>
        <h2 class="text-2xl font-bold mb-2">{content.catalog.title}</h2>
        <p class="text-gray-400 mb-4">
          {content.catalog.description}
        </p>
        <div class="flex items-center space-x-4">
          <a href="/en/tools" class={styles.cta}>
            {content.catalog.button}
          </a>
          <span
            class="text-sm px-3 py-1 bg-gray-800 rounded-full text-gray-300"
          >
            {toolsCount}
          </span>
        </div>
      </div>
      <div class="grid grid-cols-2 gap-4 text-sm">
        {
          content.catalog.benefits.map((item) => (
            <div class={styles.benefitCard}>
              <h3 class={styles.benefitTitle}>{item.title}</h3>
              <p class={styles.description}>{item.description}</p>
            </div>
          ))
        }
      </div>
    </div>
  </section>

  <section class={styles.section}>
    <h2 class="text-2xl font-bold mb-8">{content.consultations.title}</h2>
    {
      content.consultations.items.map((item) => (
        <div class={styles.contentBlock}>
          <h3 class={styles.title}>{item.title}</h3>
          <p class={styles.description}>{item.description}</p>
        </div>
      ))
    }
  </section>

  <section class={styles.section}>
    <h2 class="text-2xl font-bold mb-8">{content.services.title}</h2>
    {
      content.services.items.map((item) => (
        <div class={styles.contentBlock}>
          <h3 class={styles.title}>{item.title}</h3>
          <p class={styles.description}>{item.description}</p>
        </div>
      ))
    }
  </section>

  <section class={styles.section}>
    <h2 class="text-2xl font-bold mb-8">{content.discovery.title}</h2>
    <div class={styles.contentBlock}>
      <p class={`${styles.description} mb-4`}>
        {content.discovery.description}
      </p>
      <a href="https://cal.com/web3yoda/15min" class={styles.cta}>
        {content.discovery.cta}
      </a>
    </div>
  </section>

  <section class={styles.section}>
    <h2 class="text-2xl font-bold mb-8">{content.benefits.title}</h2>
    <div class="space-y-12">
      {
        content.benefits.items.map((benefit) => (
          <div class={styles.contentBlock}>
            <h3 class={styles.title}>{benefit.title}</h3>
            <p class={styles.description}>{benefit.description}</p>
          </div>
        ))
      }
    </div>
  </section>
</BaseLayout>

================
File: .gitignore
================
# build output
dist/
# generated types
.astro/
.vercel

# dependencies
node_modules/

# logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*


# environment variables
.env
.env.production

# macOS-specific files
.DS_Store

# jetbrains setting folder
.idea/
repopack-output.txt

================
File: astro-mentor-prompt.md
================
# Astro Development Mentor Role

You are now an experienced senior developer and Astro expert who will guide me in implementing a Web3 tools directory on web3yoda.xyz. Your role combines technical expertise with mentorship qualities.

## Core Responsibilities

1. Guide Implementation
- Reference the established POC delivery plan
- Follow Astro 5's official documentation and best practices
- Maintain existing project structure and patterns
- Focus on shipping production-ready code

2. Educational Approach
- Explain concepts when introducing them
- Point out common pitfalls and best practices
- Share relevant documentation links
- Break down complex tasks into manageable steps

3. Reference Sources
- Astro documentation (via brave-search)
- MDX documentation (via brave-search)
- Content Collections guide (via brave-search)

## Development Principles

1. Code Quality
- Follow Astro's recommended patterns
- Maintain type safety
- Ensure proper error handling
- Write maintainable code

2. Simplicity First
- Avoid unnecessary abstractions
- No premature optimization
- Keep solutions straightforward
- Only add complexity when justified

3. Focus on Deliverables
- Stick to the POC requirements
- Don't introduce unnecessary features
- Maintain existing project patterns
- Prioritize shipping working code

## Interaction Guidelines

1. When Asked for Help
- First understand the current task
- Check existing codebase
- Reference official documentation
- Provide clear, actionable guidance

2. When Explaining
- Use clear, concise language
- Provide context when needed
- Include code examples
- Reference official docs

3. When Reviewing Code
- Check against best practices
- Verify type safety
- Ensure maintainability
- Suggest improvements

## Development Process

1. For Each Task
- Understand requirements
- Check existing implementation
- Reference documentation
- Provide step-by-step guidance

2. When Adding Features
- Verify necessity
- Check integration points
- Follow existing patterns
- Test thoroughly

3. When Debugging
- Understand the issue
- Check documentation
- Provide clear solutions
- Explain the fix

## Response Format

For each interaction:

1. Task Understanding
- Confirm what needs to be done
- Reference relevant plan section
- Identify dependencies

2. Implementation Guidance
- Step-by-step instructions
- Code examples
- Documentation references

3. Learning Opportunities
- Explain key concepts
- Point out best practices
- Share helpful resources

## Error Prevention

Always:
- Verify type safety
- Check for edge cases
- Ensure error handling
- Maintain consistent patterns

Never:
- Add unnecessary complexity
- Introduce new patterns without reason
- Skip error handling
- Ignore type safety

## Key Focus Areas

1. Content Collections
- Proper schema definition
- Type safety
- Content organization
- Query optimization

2. i18n Implementation
- Follow existing patterns
- Maintain type safety
- Ensure consistent routing
- Handle translations properly

3. Component Design
- Keep it simple
- Follow existing patterns
- Ensure reusability
- Maintain type safety

Remember: Your goal is to help ship a working POC while teaching best practices, not to showcase advanced features or unnecessary complexity.

================
File: astro.config.mjs
================
// astro.config.mjs
import { defineConfig } from 'astro/config';
import react from '@astrojs/react';
import tailwind from '@astrojs/tailwind';
import vercel from '@astrojs/vercel/serverless';
import mdx from '@astrojs/mdx';

export default defineConfig({
  output: 'server',
  site: 'https://web3yoda.xyz',
  integrations: [react(), tailwind(), mdx()],
  adapter: vercel({
    analytics: true, // Enable Vercel Analytics
    imageService: true
  }),

  i18n: {
    defaultLocale: 'en',
    locales: ['en', 'pl'],
    routes: {
      pl: {
        prefix: 'pl'
      }
    },
    routing: {
      prefixDefaultLocale: false
    }
  },
  compilerOptions: {
    "types": ["astro/client"]
  },
  image: {
    service: {
      entrypoint: 'astro/assets/services/sharp',
      config: {
        limitInputPixels: 0,
        limitOutputPixels: 0,
        maximum: 30000,
      }
    }
  },
  vite: {
    envPrefix: [
      'PUBLIC_',
      'BEEHIIV_'
    ]
  },
  ssr: {
      noExternal: ['react', 'react-dom']
    },
    optimizeDeps: {
      include: ['react', 'react-dom']
    },
  domains: [],
  remotePatterns: []
});

================
File: package.json
================
{
  "name": "web3yoda",
  "type": "module",
  "version": "0.0.1",
  "scripts": {
    "dev": "astro dev",
    "start": "astro dev",
    "build": "astro check && astro build",
    "preview": "astro preview",
    "astro": "astro",
    "update-metrics": "tsx scripts/update-twitter-metrics.ts",
    "test:scraper": "tsx scripts/metrics/test.ts",
    "test:twitter-api": "tsx scripts/metrics/test-api.ts"
  },
  "dependencies": {
    "@astrojs/check": "^0.9.4",
    "@astrojs/mdx": "^4.0.5",
    "@astrojs/node": "^9.0.0",
    "@astrojs/react": "^4.1.2",
    "@astrojs/tailwind": "^5.1.4",
    "@astrojs/vercel": "^8.0.1",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@vercel/analytics": "^1.4.1",
    "astro": "^5.1.3",
    "dotenv": "^16.4.7",
    "globby": "^14.0.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "tailwindcss": "^3.4.14",
    "twitter-api-v2": "^1.19.0",
    "typescript": "^5.6.3"
  },
  "devDependencies": {
    "@tailwindcss/typography": "^0.5.15",
    "@types/node": "^20.17.14",
    "playwright": "^1.49.1",
    "tsx": "^4.19.2"
  }
}

================
File: README.md
================
# Astro Starter Kit: Minimal

```sh
npm create astro@latest -- --template minimal
```

[![Open in StackBlitz](https://developer.stackblitz.com/img/open_in_stackblitz.svg)](https://stackblitz.com/github/withastro/astro/tree/latest/examples/minimal)
[![Open with CodeSandbox](https://assets.codesandbox.io/github/button-edit-lime.svg)](https://codesandbox.io/p/sandbox/github/withastro/astro/tree/latest/examples/minimal)
[![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/withastro/astro?devcontainer_path=.devcontainer/minimal/devcontainer.json)

> 🧑‍🚀 **Seasoned astronaut?** Delete this file. Have fun!

## 🚀 Project Structure

Inside of your Astro project, you'll see the following folders and files:

```text
/
├── public/
├── src/
│   └── pages/
│       └── index.astro
└── package.json
```

Astro looks for `.astro` or `.md` files in the `src/pages/` directory. Each page is exposed as a route based on its file name.

There's nothing special about `src/components/`, but that's where we like to put any Astro/React/Vue/Svelte/Preact components.

Any static assets, like images, can be placed in the `public/` directory.

## 🧞 Commands

All commands are run from the root of the project, from a terminal:

| Command                   | Action                                           |
| :------------------------ | :----------------------------------------------- |
| `npm install`             | Installs dependencies                            |
| `npm run dev`             | Starts local dev server at `localhost:4321`      |
| `npm run build`           | Build your production site to `./dist/`          |
| `npm run preview`         | Preview your build locally, before deploying     |
| `npm run astro ...`       | Run CLI commands like `astro add`, `astro check` |
| `npm run astro -- --help` | Get help using the Astro CLI                     |

## 👀 Want to learn more?

Feel free to check [our documentation](https://docs.astro.build) or jump into our [Discord server](https://astro.build/chat).

================
File: tailwind.config.mjs
================
/** @type {import('tailwindcss').Config} */
export default {
	content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],
	theme: {
	  extend: {
		fontFamily: {
		  mono: ['Space Mono', 'monospace'],
		},
		colors: {
		  primary: '#ffffff',
		  background: '#000000',
		  accent: '#666666',
		},
		keyframes: {
		  'slide-up': {
			'0%': { transform: 'translateY(100%)', opacity: '0' },
			'100%': { transform: 'translateY(0)', opacity: '1' },
		  }
		},
		animation: {
		  'slide-up': 'slide-up 0.3s ease-out'
		}
	  },
	},
	plugins: [],
  }

================
File: tools-directory-strategy.md
================
# Web3 Tools Directory: Curation & Monitoring Strategy

## 1. Tool Curation Criteria Checklist

### Essential Requirements
- [ ] Active development (commits within last 3 months)
- [ ] Minimum adoption metrics:
  - GitHub: 500+ stars
  - Discord/Telegram: 1000+ members
  - Twitter/X: 5000+ followers
- [ ] Complete documentation
- [ ] Clear team/organization information
- [ ] Accessible support channels

### Security & Trust
- [ ] Security audit (if applicable)
- [ ] No major security incidents in last 12 months
- [ ] Clear privacy policy
- [ ] Transparent fee structure
- [ ] Open source code (preferred)
- [ ] Bug bounty program (preferred)

### User Experience
- [ ] Intuitive interface
- [ ] Mobile compatibility
- [ ] Multi-language support
- [ ] Clear error handling
- [ ] Regular updates & changelogs

### Community & Support
- [ ] Active community engagement
- [ ] Response time < 24h
- [ ] Regular updates to users
- [ ] Public roadmap
- [ ] Developer resources

## 2. Automated Monitoring System

### Technical Health Monitoring
```javascript
const monitoringConfig = {
    github: {
        checkFrequency: 'daily',
        metrics: [
            'commitFrequency',
            'issueResponseTime',
            'starCount',
            'forkCount'
        ]
    },
    social: {
        checkFrequency: 'weekly',
        platforms: [
            'twitter',
            'discord',
            'telegram'
        ]
    },
    security: {
        checkFrequency: 'daily',
        alerts: [
            'cveDatabase',
            'githubSecurityAdvisories',
            'socialMentions'
        ]
    }
}
```

### Monitoring Components

1. GitHub Activity Monitor
- Commit frequency
- Issue response time
- Pull request activity
- Star/fork growth rate

2. Social Media Monitor
- Engagement rates
- Growth metrics
- Sentiment analysis
- Support response time

3. Security Monitor
- CVE database checks
- GitHub security advisories
- Smart contract audits
- Incident reports

4. Performance Monitor
- Uptime tracking
- API response times
- Error rates
- User complaints

## 3. Tool Health Scoring System

### Scoring Categories & Weights

```typescript
interface HealthScore {
    development: {
        weight: 0.3;
        factors: {
            commitFrequency: 0.4;
            issueResolution: 0.3;
            documentationQuality: 0.3;
        };
    };
    community: {
        weight: 0.2;
        factors: {
            userGrowth: 0.3;
            engagement: 0.4;
            supportQuality: 0.3;
        };
    };
    security: {
        weight: 0.3;
        factors: {
            auditStatus: 0.4;
            incidentHistory: 0.3;
            vulnerabilityResponse: 0.3;
        };
    };
    performance: {
        weight: 0.2;
        factors: {
            uptime: 0.4;
            responseTime: 0.3;
            errorRate: 0.3;
        };
    };
}
```

### Health Status Levels
- 90-100: Excellent
- 80-89: Good
- 70-79: Fair
- Below 70: Needs Review

## 4. Automated Content Enrichment

### Content Update Pipeline

1. Data Collection
```javascript
async function enrichToolContent(toolId) {
    // Gather fresh data
    const githubData = await fetchGitHubData(toolId);
    const socialData = await fetchSocialData(toolId);
    const securityData = await fetchSecurityData(toolId);
    
    // Generate enhanced content
    const enrichedContent = await generateEnrichedContent({
        githubData,
        socialData,
        securityData
    });
    
    // Update MDX file
    await updateToolPage(toolId, enrichedContent);
}
```

2. Content Areas for Enrichment
- Feature updates
- Usage statistics
- Integration examples
- User testimonials
- Performance metrics
- Security status
- Community highlights

### Automated Updates
- Daily: Security & performance metrics
- Weekly: Usage statistics & social metrics
- Monthly: Feature updates & documentation
- Quarterly: Full content review

## Implementation Timeline

### Phase 1: Setup (Weeks 1-2)
- [ ] Implement curation criteria system
- [ ] Set up basic monitoring
- [ ] Create scoring system
- [ ] Establish update pipeline

### Phase 2: Testing (Weeks 3-4)
- [ ] Test with 5 top tools
- [ ] Adjust scoring weights
- [ ] Refine monitoring rules
- [ ] Optimize update frequency

### Phase 3: Scaling (Weeks 5-8)
- [ ] Expand to 20 tools
- [ ] Implement automated alerts
- [ ] Add community feedback loop
- [ ] Deploy full monitoring system

### Phase 4: Optimization (Weeks 9-12)
- [ ] Analyze system performance
- [ ] Optimize resource usage
- [ ] Implement improvements
- [ ] Document best practices

## Maintenance Requirements

### Daily Tasks
- Monitor health scores
- Review security alerts
- Check performance metrics
- Update critical information

### Weekly Tasks
- Generate health reports
- Update social metrics
- Review user feedback
- Check content accuracy

### Monthly Tasks
- Full content audit
- Update scoring weights
- Review monitoring rules
- Generate trend reports

## Success Metrics

### Quality Metrics
- Content freshness (< 30 days old)
- Accuracy rate (> 95%)
- User satisfaction (> 4.5/5)
- Tool health scores (> 85%)

### Growth Metrics
- Monthly new tools added
- Content update frequency
- User engagement rates
- Directory usage statistics

## Review Process

### Quarterly Review
- System effectiveness
- Scoring accuracy
- Resource usage
- User feedback
- Content quality
- Monitoring performance

### Annual Assessment
- Strategy effectiveness
- Resource allocation
- Growth metrics
- User satisfaction
- System scalability
- Future improvements

================
File: tsconfig.json
================
{
  "extends": "astro/tsconfigs/base",
  "include": [
    ".astro/types.d.ts",
    "**/*"
  ],
  "exclude": [
    "dist"
  ],
  "compilerOptions": {
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "jsxImportSource": "react",
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "src/*"
      ]
    }
  }
}

================
File: vercel.json
================
{
    "cleanUrls": true,
    "trailingSlash": false,
    "headers": [
      {
        "source": "/(.*)",
        "headers": [
          {
            "key": "X-Content-Type-Options",
            "value": "nosniff"
          },
          {
            "key": "X-Frame-Options",
            "value": "DENY"
          },
          {
            "key": "X-XSS-Protection",
            "value": "1; mode=block"
          }
        ]
      }
    ]
  }

================
File: x-metrics-strategy.md
================
# X/Twitter-First Strategy for Web3 Tools Directory

## Overview

This document outlines our strategy for using X (formerly Twitter) as the primary source of metrics and dynamics for the Web3 tools directory. The focus is on leveraging Crypto Twitter (CT) engagement to provide valuable insights and maintain fresh, relevant content.

## 1. Core Metrics

### Primary Metrics
- Follower count
- Follower growth rate (daily/weekly)
- Tweet frequency
- Engagement rates:
  * Likes per tweet
  * Retweets/reposts
  * Reply counts
  * Quote tweets

### Secondary Metrics
- Response time to user queries
- Announcement frequency
- Community sentiment score
- Verified mentions by influencers

## 2. Dynamic Features

### Weekly Trending Tools
- Based on:
  * Highest follower growth %
  * Most engaging updates
  * Significant announcements
  * Community buzz/mentions
  * New feature launches
  * Partnership announcements

### Monthly Insights
- Growth trends
- Most improved tools
- Most active communities
- Key updates digest
- New tools spotlight
- Community favorites

### Quarterly Reports
- Market trend analysis
- Rising stars
- Category leaders
- Community choice awards
- Adoption metrics

## 3. Content Generation

### Automated Updates
- Daily:
  * Metrics collection
  * Growth tracking
  * Engagement monitoring

- Weekly:
  * Trending tools report
  * Notable updates summary
  * Growth highlights

- Monthly:
  * Comprehensive analysis
  * Category rankings
  * Growth leaders

### Content Types
1. Tool Cards
   - Current metrics
   - Growth indicators
   - Recent highlights
   - Community sentiment

2. Comparison Views
   - Head-to-head metrics
   - Growth trajectories
   - Category rankings
   - Engagement scores

3. Trending Sections
   - Weekly winners
   - Rising stars
   - Most discussed
   - New additions

## 4. Technical Implementation

### Data Collection
```typescript
interface XMetrics {
  handle: string;
  metrics: {
    followers: number;
    followersGrowth: {
      daily: number;
      weekly: number;
      monthly: number;
    };
    engagement: {
      likes: number;
      retweets: number;
      replies: number;
      quotes: number;
    };
    activity: {
      tweetFrequency: number;
      responseTime: number;
      lastUpdate: Date;
    };
  };
  trends: {
    growthScore: number;
    engagementScore: number;
    communityScore: number;
    overallRank: number;
  };
}
```

### Update Frequency
- Metrics: Every 6 hours
- Growth rates: Daily
- Rankings: Weekly
- Comprehensive analysis: Monthly

### Alert System
- Significant follower changes (>5% in 24h)
- Viral tweets (engagement spike)
- Important announcements
- Security updates
- Major partnerships

## 5. Content Enhancement

### Tool Pages
- Live metrics display
- Growth charts
- Recent updates
- Community highlights

### Directory Features
- Sort by growth
- Filter by activity
- Category leaders
- Trending tools

### Weekly Roundups
- Top performers
- Notable updates
- Community picks
- Emerging trends
- Market insights

## 6. Implementation Phases

### Phase 1: Basic Metrics (Week 1-2)
- [x] Set up X API integration
- [ ] Implement basic metrics collection
- [ ] Create metrics storage system
- [ ] Build basic display components

### Phase 2: Growth Tracking (Week 3-4)
- [ ] Implement growth calculations
- [ ] Create trending algorithm
- [ ] Build comparison features
- [ ] Add basic alerts

### Phase 3: Engagement Analysis (Week 5-6)
- [ ] Add engagement metrics
- [ ] Implement sentiment analysis
- [ ] Create activity scores
- [ ] Build ranking system

### Phase 4: Content Automation (Week 7-8)
- [ ] Set up automated reports
- [ ] Implement trending posts
- [ ] Create update digests
- [ ] Build newsletter system

## 7. Success Metrics

### Growth Metrics
- Directory page views
- Tool page engagement
- Return visitors
- Time on site

### Engagement Metrics
- User interactions
- Tool comparisons
- Newsletter subscriptions
- Social shares

### Content Metrics
- Content freshness
- Update frequency
- Automation success rate
- User feedback

## 8. Future Enhancements

### Planned Features
1. AI-powered trend prediction
2. Custom alerts for users
3. Tool recommendation engine
4. Integration with other platforms
5. Advanced analytics dashboard

### Community Features
1. User watchlists
2. Custom comparisons
3. Tool reviews
4. Community rankings

## 9. Maintenance Plan

### Daily Tasks
- Monitor data collection
- Verify metrics accuracy
- Update growth rates
- Check alert triggers

### Weekly Tasks
- Generate reports
- Update rankings
- Verify trending tools
- Create content digests

### Monthly Tasks
- Comprehensive analysis
- System optimization
- Feature updates
- Content strategy review

## 10. Risk Management

### Data Reliability
- Multiple data points verification
- Error checking systems
- Manual verification of outliers
- Backup data sources

### System Monitoring
- API limits tracking
- Error rate monitoring
- Performance metrics
- System health checks

### Content Quality
- Automated content review
- Manual spot checks
- User feedback system
- Quality metrics tracking
