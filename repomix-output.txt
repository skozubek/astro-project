This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-14T20:23:39.834Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
public/
  favicon.svg
src/
  components/
    astro/
      Footer.astro
      Header.astro
      LanguagePicker.astro
      Newsletter.astro
      seo.astro
    react/
      NewsletterForm.tsx
      Toast.tsx
    tools/
      ToolCard.astro
  content/
    home/
      en.json
      pl.json
    tools/
      wallets/
        unisat.mdx
    ui/
      en.json
      pl.json
    config.ts
  i18n/
    i18n-config.ts
    utils.ts
  layouts/
    BaseLayout.astro
  pages/
    [lang]/
      tools/
        [...slug].astro
        index.astro
    api/
      subscribe.ts
    pl/
      index.astro
    debug-routes.astro
    debug.astro
    index.astro
.gitignore
astro-mentor-prompt.md
astro.config.mjs
package.json
README.md
tailwind.config.mjs
tsconfig.json
vercel.json

================================================================
Files
================================================================

================
File: public/favicon.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 128 128">
    <path d="M50.4 78.5a75.1 75.1 0 0 0-28.5 6.9l24.2-65.7c.7-2 1.9-3.2 3.4-3.2h29c1.5 0 2.7 1.2 3.4 3.2l24.2 65.7s-11.6-7-28.5-7L67 45.5c-.4-1.7-1.6-2.8-2.9-2.8-1.3 0-2.5 1.1-2.9 2.7L50.4 78.5Zm-1.1 28.2Zm-4.2-20.2c-2 6.6-.6 15.8 4.2 20.2a17.5 17.5 0 0 1 .2-.7 5.5 5.5 0 0 1 5.7-4.5c2.8.1 4.3 1.5 4.7 4.7.2 1.1.2 2.3.2 3.5v.4c0 2.7.7 5.2 2.2 7.4a13 13 0 0 0 5.7 4.9v-.3l-.2-.3c-1.8-5.6-.5-9.5 4.4-12.8l1.5-1a73 73 0 0 0 3.2-2.2 16 16 0 0 0 6.8-11.4c.3-2 .1-4-.6-6l-.8.6-1.6 1a37 37 0 0 1-22.4 2.7c-5-.7-9.7-2-13.2-6.2Z" />
    <style>
        path { fill: #000; }
        @media (prefers-color-scheme: dark) {
            path { fill: #FFF; }
        }
    </style>
</svg>

================
File: src/components/astro/Footer.astro
================
---
// src/components/astro/Footer.astro
import { useTranslations } from "../../i18n/utils";
import { X, Mail } from "lucide-react";
import Newsletter from "./Newsletter.astro";

const t = await useTranslations(Astro.currentLocale as "en" | "pl");
---

<footer class="py-16 border-t border-gray-600">
  <div class="max-w-3xl mx-auto px-8">
    <div class="mb-12">
      <div class="flex items-center mb-6">
        <span class="text-2xl font-bold">Web3Yoda</span>
      </div>
      <p class="text-gray-400 text-lg">{t("footer.description")}</p>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-12">
      <Newsletter />
    </div>

    <div
      class="flex justify-between items-center pt-8 border-t border-gray-600"
    >
      <p class="text-gray-400 text-sm">{t("copyright")}</p>
      <div class="flex space-x-6">
        <a
          href="https://twitter.com/phantom0fweb3"
          class="text-gray-400 hover:text-white transition-colors"
          aria-label="Twitter"
        >
          <X className="h-7 w-7" />
        </a>
        <a
          href="mailto:web3yoda.xyz@pm.me"
          class="text-gray-400 hover:text-white transition-colors"
          aria-label="Email"
        >
          <Mail className="h-7 w-7" />
        </a>
      </div>
    </div>
  </div>
</footer>

================
File: src/components/astro/Header.astro
================
---
// src/components/astro/Header.astro
import LanguagePicker from "./LanguagePicker.astro";
import { useTranslations } from "@/i18n/utils";

const t = await useTranslations(Astro.currentLocale as "en" | "pl");
---

<header
  class="fixed top-0 left-0 right-0 z-50 bg-black/80 backdrop-blur-sm border-b border-gray-800"
>
  <div class="max-w-3xl mx-auto px-8">
    <div class="flex items-center justify-between h-28">
      <a href="/" class="flex items-center group">
        <svg
          class="w-20 h-20 transition-transform duration-300 group-hover:scale-110"
          viewBox="0 0 64 64"
        >
          <rect x="16" y="8" width="32" height="32" fill="#ffffff"></rect>
          <rect x="24" y="16" width="4" height="4" fill="#000000"></rect>
          <rect x="36" y="16" width="4" height="4" fill="#000000"></rect>
          <rect x="24" y="28" width="16" height="4" fill="#000000"></rect>
        </svg>
        <span class="ml-3 text-xl font-bold">Web3Yoda</span>
      </a>

      <nav class="flex items-center space-x-8">
        <LanguagePicker />
        <a
          href="https://twitter.com/phantom0fweb3"
          class="text-gray-400 hover:text-white transition-colors duration-300"
        >
          {t("nav.twitter")}
        </a>
        <a
          href="https://cal.com/web3yoda/15min"
          class="px-4 py-2 bg-white text-black font-bold hover:bg-gray-400 hover:text-white transition-colors duration-300 ease-in-out"
        >
          {t("nav.schedule")}
        </a>
      </nav>
    </div>
  </div>
</header>

<div class="h-28"></div>

================
File: src/components/astro/LanguagePicker.astro
================
---
// src/components/astro/LanguagePicker.astro
import { languages } from "../../i18n/utils";
---

<style>
  .custom-select {
    appearance: none;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="gray"><path d="M5.5 8l4.5 4.5L14.5 8H5.5z"/></svg>');
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 16px;
    padding-right: 30px;
  }
</style>

<select
  class="custom-select bg-transparent border border-gray-600 rounded px-3 py-2 text-gray-400 focus:border-white transition-colors"
  onchange="window.location.pathname = this.value"
>
  {
    Object.entries(languages).map(([lang, label]) => (
      <option
        value={lang === "en" ? "/" : `/${lang}/`}
        selected={Astro.currentLocale === lang}
      >
        {label}
      </option>
    ))
  }
</select>

================
File: src/components/astro/Newsletter.astro
================
---
// src/components/astro/Newsletter.astro
import { useTranslations } from "../../i18n/utils";
import NewsletterForm from "../react/NewsletterForm";
import Toast from "../react/Toast";
import { getCollection } from "astro:content";
import type { CollectionEntry } from "astro:content";

const currentLocale = Astro.currentLocale as "en" | "pl";
const t = await useTranslations(currentLocale);

const translations = {
  title: t("newsletter.title"),
  description: t("newsletter.description"),
  placeholder: t("newsletter.placeholder"),
  button: t("newsletter.button"),
};

// Get UI translations for Toast component
const uiCollections = await getCollection("ui");
const uiTranslations = uiCollections.find(
  (entry) => entry.id === currentLocale
)?.data;

if (!uiTranslations) {
  throw new Error(`No UI translations found for locale: ${currentLocale}`);
}
---

<div class="newsletter-section">
  <NewsletterForm client:load translations={translations} />
  <Toast
    client:load
    data-locale={currentLocale}
    translations={uiTranslations as Record<string, any>}
  />
</div>

================
File: src/components/astro/seo.astro
================
---
// src/components/astro/SEO.astro
interface Props {
  title: string;
  description: string;
  image?: string;
  canonicalUrl?: string;
  type?: string;
  currentLocale: string;
  alternateUrls: {
    [key: string]: string;
  };
}

const {
  title,
  description,
  image = "/default-og.png",
  canonicalUrl,
  type = "website",
  currentLocale,
  alternateUrls,
} = Astro.props;

// Get the current URL
const currentUrl = Astro.url.href;
---

<!-- Basic Meta Tags -->
<title>{title}</title>
<meta name="description" content={description} />
<link rel="canonical" href={canonicalUrl || currentUrl} />

<!-- Open Graph / Facebook -->
<meta property="og:type" content={type} />
<meta property="og:url" content={currentUrl} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:image" content={new URL(image, Astro.url)} />
<meta property="og:locale" content={currentLocale} />

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={currentUrl} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={new URL(image, Astro.url)} />

<!-- Language Alternates -->
<link rel="alternate" href={alternateUrls["x-default"]} hreflang="x-default" />
{
  Object.entries(alternateUrls)
    .filter(([lang]) => lang !== "x-default")
    .map(([lang, url]) => <link rel="alternate" href={url} hreflang={lang} />)
}

<!-- JSON-LD Schema -->
<script
  type="application/ld+json"
  set:html={JSON.stringify({
    "@context": "https://schema.org",
    "@type": "WebSite",
    url: currentUrl,
    name: title,
    description: description,
    inLanguage: currentLocale,
    alternateName: Object.values(alternateUrls),
  })}
/>

================
File: src/components/react/NewsletterForm.tsx
================
// src/components/react/NewsletterForm.tsx
import React, { useState } from 'react';
import type { ToastEvent } from './Toast';

interface NewsletterFormProps {
  translations: {
    title: string;
    description: string;
    placeholder: string;
    button: string;
  };
}

const NewsletterForm: React.FC<NewsletterFormProps> = ({ translations }) => {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    const form = e.currentTarget;
    const email = new FormData(form).get('email') as string;

    try {
      const response = await fetch('/api/subscribe', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email })
      });

      const data = await response.json();

      const event = new CustomEvent<ToastEvent['detail']>('show-toast', {
        detail: {
          messageKey: data.success 
            ? 'newsletter.toast.success'
            : data.error === 'Please provide a valid email address'
              ? 'newsletter.toast.error.invalid'
              : data.error === 'Server configuration error'
                ? 'newsletter.toast.error.server'
                : 'newsletter.toast.error.general',
          type: data.success ? 'success' : 'error'
        }
      });
      window.dispatchEvent(event);

      if (data.success) {
        form.reset();
      }
    } catch (error) {
      window.dispatchEvent(new CustomEvent<ToastEvent['detail']>('show-toast', {
        detail: {
          messageKey: 'newsletter.toast.error.general',
          type: 'error'
        }
      }));
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div>
      <h3 className="font-bold mb-4">{translations.title}</h3>
      <p className="text-gray-400 mb-4">{translations.description}</p>

      <form onSubmit={handleSubmit} className="space-y-4">
        <div className="flex gap-2">
          <input
            type="email"
            name="email"
            required
            placeholder={translations.placeholder}
            className="flex-1 px-4 py-2 bg-transparent border border-gray-600 rounded-md focus:outline-none focus:border-white"
            disabled={isSubmitting}
          />
          <button
            type="submit"
            className="px-6 py-2 bg-white text-black font-bold rounded-md hover:bg-gray-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            disabled={isSubmitting}
          >
            {translations.button}
          </button>
        </div>
      </form>
    </div>
  );
};

export default NewsletterForm;

================
File: src/components/react/Toast.tsx
================
// src/components/react/Toast.tsx
import React, { useEffect, useState } from 'react';
import { X, Check, AlertCircle } from 'lucide-react';

export type ToastType = 'success' | 'error';

export interface ToastEvent {
  detail: {
    messageKey: string;
    type: ToastType;
  }
}

interface ToastProps {
  'data-locale': 'en' | 'pl';
  translations: Record<string, any>;
}

const Toast: React.FC<ToastProps> = ({ 'data-locale': locale, translations }) => {
  const [isVisible, setIsVisible] = useState(false);
  const [messageKey, setMessageKey] = useState<string | null>(null);
  const [type, setType] = useState<ToastType>('success');

  useEffect(() => {
    const handleToast = (event: CustomEvent<ToastEvent['detail']>) => {
      setMessageKey(event.detail.messageKey);
      setType(event.detail.type);
      setIsVisible(true);
    };

    window.addEventListener('show-toast', handleToast as EventListener);

    return () => {
      window.removeEventListener('show-toast', handleToast as EventListener);
    };
  }, []);

  useEffect(() => {
    if (isVisible) {
      const timer = setTimeout(() => {
        setIsVisible(false);
      }, 5000);
      return () => clearTimeout(timer);
    }
  }, [isVisible]);

  if (!isVisible || !messageKey || !translations) return null;

  // Get the message from nested keys
  const message = messageKey.split('.').reduce((obj: any, key: string) => obj?.[key], translations);

  return (
    <div className="fixed bottom-4 right-4 z-50 animate-slide-up">
      <div
        className={`flex items-center gap-2 px-4 py-3 rounded-lg shadow-lg ${
          type === 'success' ? 'bg-green-500' : 'bg-red-500'
        }`}
      >
        {type === 'success' ? (
          <Check className="w-5 h-5 text-white" />
        ) : (
          <AlertCircle className="w-5 h-5 text-white" />
        )}
        <p className="text-white font-medium">{message}</p>
        <button
          onClick={() => setIsVisible(false)}
          className="ml-4 text-white hover:text-gray-200 transition-colors"
          aria-label="Close notification"
        >
          <X className="w-4 h-4" />
        </button>
      </div>
    </div>
  );
};

export default Toast;

================
File: src/components/tools/ToolCard.astro
================
---
// src/components/tools/ToolCard.astro
import type { CollectionEntry } from "astro:content";
import { Image } from "astro:assets";
import { useTranslations } from "@/i18n/utils";
import type { Tool } from "@/content/config";

interface Props {
  tool: CollectionEntry<"tools">;
  lang: "en" | "pl";
}

const { tool, lang } = Astro.props;
const t = await useTranslations(lang);

// Type-safe access to localized content
const localizedContent = tool.data.i18n[lang];

// Ensure localized content exists
if (!localizedContent) {
  throw new Error(`Missing localized content for language: ${lang}`);
}

// Generate the tool URL
const toolUrl = `/${lang}/tools/${tool.id.split("/").pop()}`;

// Tailwind classes for consistent styling
const classes = {
  card: "border border-gray-700 rounded-lg p-6 hover:border-gray-500 transition-colors",
  logoContainer: "w-16 h-16 mb-4",
  logo: "w-full h-full object-contain",
  logoPlaceholder:
    "w-full h-full bg-gray-800 rounded flex items-center justify-center",
  title: "text-xl font-bold mb-2",
  description: "text-gray-400 mb-4 line-clamp-2",
  features: "text-sm text-gray-400 space-y-1 mb-4",
  featureItem: "flex items-start",
  metadata: "flex flex-wrap gap-2 mt-auto",
  badge: "px-2 py-1 bg-gray-800 rounded text-sm",
};
---

<article class={classes.card}>
  <a href={toolUrl} class="block">
    {/* Tool logo with error boundary */}
    <div class={classes.logoContainer}>
      {
        tool.data.logo ? (
          <Image
            src={tool.data.logo}
            alt={localizedContent.title}
            width={64}
            height={64}
            class={classes.logo}
          />
        ) : (
          <div class={classes.logoPlaceholder}>
            <span class="text-xs text-gray-400">No logo</span>
          </div>
        )
      }
    </div>

    {/* Tool info */}
    <h3 class={classes.title}>{localizedContent.title}</h3>
    <p class={classes.description}>{localizedContent.description}</p>

    {/* Features preview with validation */}
    {
      localizedContent.features.length > 0 && (
        <ul class={classes.features}>
          {localizedContent.features.slice(0, 3).map((feature) => (
            <li class={classes.featureItem}>
              <span class="mr-2">•</span>
              {feature}
            </li>
          ))}
        </ul>
      )
    }

    {/* Tool metadata */}
    <div class={classes.metadata}>
      <span class={classes.badge}>
        {t(`tools.status.${tool.data.status}`)}
      </span>
      {
        tool.data.metadata?.pricing && (
          <span class={classes.badge}>
            {t(`tools.pricing.${tool.data.metadata.pricing}`)}
          </span>
        )
      }
    </div>
  </a>
</article>

================
File: src/content/home/en.json
================
{
    "hero": {
      "title": "Your Web3 Onboarding Guides",
      "subtitle": "Start your Web3 journey with a seasoned guide who's walked the path before you. Skip the theory and dive into practical blockchain knowledge from someone who lives and breathes it daily"
    },
    "consultations": {
      "title": "Coaching Sessions",
      "items": [
        {
          "title": "Web3 Basics",
          "description": "All you need to start your transition into Web3"
        },
        {
          "title": "NFT & Digital Collectibles",
          "description": "Deep dive into NFTs, digital collectibles & marketplaces"
        },
        {
          "title": "Multi-Chain Mastery",
          "description": "Advanced guidance on navigating multiple blockchain ecosystems"
        }
      ]
    },
    "services": {
      "title": "Services",
      "items": [
        {
          "title": "Custom Tools Development",
          "description": "Building websites and tools with wallets auth and wallets integrations, workflow automations with AI & AI agents, eg. X (Twitter) bots"
        }
      ]
    },
    "discovery": {
      "title": "Free Discovery Call",
      "description": "15 min call to get to know your personal needs",
      "cta": "Schedule a Call"
    },
    "benefits": {
      "title": "Why Choose Web3Yoda?",
      "items": [
        {
          "title": "Battle-Tested Web Veterans",
          "description": "Ex-Googler (SQE team), Web2/Web3 brands founders & builders, with hands-on experience navigating the evolving Web3 landscape"
        },
        {
          "title": "Real-World Experience",
          "description": "Daily practitioners & builders actively using DeFi, trading crypto, perps, NFTs, ordinals & memecoins. We don't just teach it, We live it"
        },
        {
          "title": "Focused Mastery Path",
          "description": "Tailored guidance focusing on exactly what you need to master - no fluff, just practical Web3 skills"
        }
      ]
    }
  }

================
File: src/content/home/pl.json
================
{
    "hero": {
      "title": "Twój przewodnik po świecie web3",
      "subtitle": "Zacznij bezpiecznie korzystać z technologii blockchain. Praktyczna wiedza bez zbędnej teorii"
    },
    "consultations": {
      "title": "Konsultacje",
      "items": [
        {
          "title": "Podstawy Web3",
          "description": "Wszystko, czego potrzebujesz, by przejść gładko z Web2 do Web3 i bezpiecznie się tam poruszać"
        },
        {
          "title": "NFT, ordinals - cyfrowe tokeny kolekcjonerskie",
          "description": "Naucz się kolekcjonować cyfrowe artefakty. Jak, gdzie kupować, sprzedawać i przechowywać tokeny NFT w sieciach ETH, SOL, BTC i innych"
        },
        {
          "title": "Bitcoin, Ethereum, Solana?",
          "description": "Multi-chain w praktyce. Sztuka poruszania się między różnymi sieciami blockchain"
        }
      ]
    },
    "services": {
      "title": "Usługi",
      "items": [
        {
          "title": "Budowa spersonalizowanych narzędzi i automatyzacje",
          "description": "Budowa stron www z integracją portfeli / autoryzacją portfelem, automatyzacje procesów z wykorzystaniem AI, np. boty na platformie X (Twitter)"
        }
      ]
    },
    "discovery": {
      "title": "Darmowa Konsultacja",
      "description": "15-minutowa rozmowa, aby poznać Twoje potrzeby",
      "cta": "Umów Rozmowę"
    },
    "benefits": {
      "title": "Dlaczego Web3Yoda?",
      "items": [
        {
          "title": "Weterani Internetu",
          "description": "W Internecie od samego jego początku, wiemy jak poruszać się w tym ciągle zmieniającym się środowisku. Mamy doświadczenie w tworzeniu, optymalizacji stron i sklepów internetowych oraz aplikacji web'owych, które zdybywaliśmy w wielkich korporacjach, jak Google, ale i w mniejszych startupach"
        },
        {
          "title": "Doświadczenie Web3 z Pierwszej Ręki",
          "description": "Aktywnie poruszamy się na rynkach krypto, NFT, memecoinów i aktywnie udzielamy się w społecznościach w okół wielu projektów Web3"
        },
        {
          "title": "Konsultacje szyte na miarę",
          "description": "Spersonalizowane wskazówki skupiające się dokładnie na tym, czego potrzebujesz - praktyczne umiejętności Web3"
        }
      ]
    }
  }

================
File: src/content/tools/wallets/unisat.mdx
================
---
id: "unisat-wallet"
logo: "/src/assets/tools/unisat/logo.png"  # Path relative to project root
screenshot: "/src/assets/tools/unisat/screenshot.png"
website: "https://unisat.io"
github: "https://github.com/unisat-wallet"
category: "wallets"
ecosystems: ["bitcoin"]
status: "active"
lastUpdated: 2024-01-14
i18n:
  en:
    title: "UniSat Wallet"
    description: "Self-custodial browser extension wallet for Bitcoin, Ordinals, and BRC-20 tokens"
    features:
      - "Complete Bitcoin transaction support with custom fee settings"
      - "Full Ordinals support with inscription viewer"
      - "BRC-20 token management with built-in marketplace"
  pl:
    title: "Portfel UniSat"
    description: "Portfel w formie rozszerzenia przeglądarki dla Bitcoin, Ordinals i tokenów BRC-20"
    features:
      - "Pełna obsługa transakcji Bitcoin z możliwością ustawienia opłat"
      - "Wsparcie dla Ordinals z przeglądarką inskrypcji"
      - "Zarządzanie tokenami BRC-20 z wbudowaną giełdą"
metadata:
  tags: ["bitcoin", "ordinals", "brc20"]
  pricing: "free"
---

## Overview

UniSat Wallet is a comprehensive Bitcoin wallet solution designed for the emerging Bitcoin NFT and token standards. It stands out as one of the leading wallets for Ordinals and BRC-20 tokens, combining traditional Bitcoin functionality with new token capabilities.

## Key Features

### Bitcoin Operations
- Standard BTC transactions with RBF support
- Multiple address formats (Legacy, Native SegWit, Taproot)
- Custom fee settings with fee estimation
- UTXO management and coin control

### Ordinals Support
- View and transfer inscriptions
- Built-in inscription marketplace
- Bulk inscription operations
- Ordinals-aware UTXO management

### BRC-20 Integration
- Token balances and transfers
- Market price tracking
- Trading interface
- Token minting support

================
File: src/content/ui/en.json
================
{
  "id": "en",
  "meta": {
    "description": "Start your Web3 journey with a seasoned guide. Expert consultations and practical knowledge for Web3 transition."
  },
  "nav": {
    "schedule": "Schedule a Call",
    "twitter": "X (Twitter)"
  },
  "newsletter": {
    "title": "Newsletter",
    "description": "Get the latest Web3 insights delivered to your inbox",
    "placeholder": "Enter your email",
    "button": "Subscribe",
    "toast": {
      "success": "Thanks for subscribing!",
      "error": {
        "invalid": "Please provide a valid email address",
        "failed": "Failed to subscribe. Please try again.",
        "server": "Server configuration error",
        "general": "Something went wrong. Please try again."
      }
    }
  },
  "tools": {
    "title": "Web3 Tools Directory",
    "categories": {
      "wallets": "Wallets",
      "marketplaces": "Marketplaces",
      "defi": "DeFi",
      "analytics": "Analytics",
      "security": "Security",
      "infrastructure": "Infrastructure",
      "development": "Development",
      "identity": "Identity",
      "governance": "Governance",
      "social": "Social",
      "storage": "Storage",
      "gaming": "Gaming",
      "oracles": "Oracles",
      "bridges": "Bridges",
      "data": "Data",
      "other": "Other"
    },
    "ecosystems": {
      "bitcoin": "Bitcoin",
      "ethereum": "Ethereum",
      "solana": "Solana",
      "cardano": "Cardano",
      "polkadot": "Polkadot",
      "cosmos": "Cosmos",
      "multichain": "Multichain",
      "other": "Other"
    },
    "status": {
      "active": "Active",
      "beta": "Beta",
      "deprecated": "Deprecated"
    },
    "filters": {
      "all": "All Tools",
      "category": "Category",
      "ecosystem": "Ecosystem",
      "status": "Status"
    },
    "pricing": {
      "free": "Free",
      "paid": "Paid",
      "hybrid": "Hybrid",
      "contact": "Contact for Pricing"
    }
  },
  "footer": {
    "description": "Bridging the gap between Web2 and Web3 through expert guidance and education."
  },
  "copyright": "© 2024 Web3Yoda. All rights reserved."
}

================
File: src/content/ui/pl.json
================
{
    "id": "pl",
    "meta": {
      "description": "Zacznij bezpiecznie korzystać z technologii blockchain. Praktyczna wiedza bez zbędnej teorii"
    },
    "nav": {
      "schedule": "Umów rozmowę",
      "twitter": "X (Twitter)"
    },
    "newsletter": {
      "title": "Newsletter",
      "description": "Otrzymuj najnowsze informacje o Web3 prosto na swoją skrzynkę",
      "placeholder": "Twój email",
      "button": "Subskrybuj",
      "toast": {
        "success": "Dziękujemy za subskrypcję!",
        "error": {
          "invalid": "Podaj prawidłowy adres email",
          "failed": "Nie udało się zapisać. Spróbuj ponownie.",
          "server": "Błąd konfiguracji serwera",
          "general": "Coś poszło nie tak. Spróbuj ponownie."
        }
      }
    },
    "tools": {
      "title": "Katalog Narzędzi Web3",
      "categories": {
        "wallets": "Portfele",
        "marketplaces": "Giełdy",
        "defi": "DeFi",
        "analytics": "Analityka",
        "security": "Bezpieczeństwo",
        "infrastructure": "Infrastruktura",
        "development": "Rozwój",
        "identity": "Tożsamość",
        "governance": "Zarządzanie",
        "social": "Social",
        "storage": "Przechowywanie",
        "gaming": "Gry",
        "oracles": "Orakula",
        "bridges": "Mosty",
        "data": "Dane",
        "other": "Inne"
      },
      "ecosystems": {
        "bitcoin": "Bitcoin",
        "ethereum": "Ethereum",
        "solana": "Solana",
        "cardano": "Cardano",
        "polkadot": "Polkadot",
        "cosmos": "Cosmos",
        "multichain": "Multichain",
        "other": "Inne"
      },
      "status": {
        "active": "Aktywne",
        "beta": "Beta",
        "deprecated": "Przestarzałe"
      },
      "filters": {
        "all": "Wszystkie Narzędzia",
        "category": "Kategoria",
        "ecosystem": "Ekosystem",
        "status": "Status"
      },
      "pricing": {
        "free": "Darmowe",
        "paid": "Płatne",
        "hybrid": "Hybrydowe",
        "contact": "Skontaktuj się po cenę"
      }
    },
    "footer": {
      "description": "Łączymy świat Web2 i Web3 poprzez profesjonalne doradztwo i edukację."
    },
    "copyright": "© 2024 Web3Yoda. Wszelkie prawa zastrzeżone."
  }

================
File: src/content/config.ts
================
// src/content/config.ts
import { defineCollection, reference, z } from 'astro:content';
import { glob } from 'astro/loaders';

// UI collection schema
const uiSchema = z.object({
  id: z.enum(['en', 'pl']),
  meta: z.object({
    description: z.string(),
  }),
  nav: z.object({
    schedule: z.string(),
    twitter: z.string(),
  }),
  newsletter: z.object({
    title: z.string(),
    description: z.string(),
    placeholder: z.string(),
    button: z.string(),
    toast: z.object({
      success: z.string(),
      error: z.object({
        invalid: z.string(),
        failed: z.string(),
        server: z.string(),
        general: z.string(),
      }),
    }),
  }),
  tools: z.object({
    title: z.string(),
    categories: z.record(z.string()),
    ecosystems: z.record(z.string()),
    status: z.record(z.string()),
    filters: z.record(z.string()),
    pricing: z.record(z.string()),
  }),
  footer: z.object({
    description: z.string(),
  }),
  copyright: z.string(),
});

// Home collection schema
const homeSchema = z.object({
  hero: z.object({
    title: z.string(),
    subtitle: z.string()
  }),
  consultations: z.object({
    title: z.string(),
    items: z.array(z.object({
      title: z.string(),
      description: z.string()
    }))
  }),
  services: z.object({
    title: z.string(),
    items: z.array(z.object({
      title: z.string(),
      description: z.string()
    }))
  }),
  discovery: z.object({
    title: z.string(),
    description: z.string(),
    cta: z.string()
  }),
  benefits: z.object({
    title: z.string(),
    items: z.array(z.object({
      title: z.string(),
      description: z.string()
    }))
  })
});

/**
 * Core categories for Web3 tools
 */
const categorySchema = z.enum([
  'wallets',         // Crypto wallets, key management
  'marketplaces',    // NFT and token marketplaces
  'defi',           // DeFi protocols and tools
  'infrastructure', // RPCs, nodes, indexers
  'security',       // Security tools, audit tools
  'analytics',      // Data analytics, market tracking
  'other'          // Catch-all for edge cases
]);

/**
 * Tool status indicators
 */
const statusSchema = z.enum([
  'active',     // Tool is actively maintained
  'beta',       // Tool is in testing phase
  'deprecated'  // Tool is no longer maintained
]);

/**
 * Supported blockchain ecosystems
 */
const ecosystemSchema = z.array(z.enum([
  'bitcoin',    // BTC, Ordinals, Lightning
  'ethereum',   // ETH, EVM chains
  'solana',     // SOL ecosystem
  'multichain', // Cross-chain solutions
  'other'       // Other blockchains
])).min(1);

/**
 * Schema for multilingual tool content
 */
const toolTranslationsSchema = z.record(z.enum(['en', 'pl']), z.object({
  title: z.string(),
  description: z.string(),
  features: z.array(z.string()),
}));

/**
 * Simplified tool schema without image validation
 */
const toolSchema = z.object({
  id: z.string(),
  logo: z.string(),  // Simplified to just expect a string path
  screenshot: z.string().optional(),
  website: z.string().url(),
  github: z.string().url().optional(),
  category: categorySchema,
  ecosystems: ecosystemSchema,
  status: statusSchema,
  lastUpdated: z.date(),
  i18n: toolTranslationsSchema,
  metadata: z.object({
    tags: z.array(z.string()),
    pricing: z.enum(['free', 'paid', 'hybrid']),
  }).optional(),
});

// Collections Configuration
const tools = defineCollection({
  schema: toolSchema,
  // Update the loader to use glob for loading MDX files
  loader: glob({
    pattern: "tools/**/*.mdx",
    base: "./src/content"
  })
});

const home = defineCollection({
  type: 'data',
  schema: homeSchema,
});

const ui = defineCollection({
  type: 'data',
  schema: uiSchema,
});

// Export the collections
export const collections = { tools, home, ui };

// Export type helpers
export type Tool = z.infer<typeof toolSchema>;
export type ToolTranslations = z.infer<typeof toolTranslationsSchema>;
export type ToolCategory = z.infer<typeof categorySchema>;
export type ToolStatus = z.infer<typeof statusSchema>;
export type ToolEcosystem = z.infer<typeof ecosystemSchema>[number];

================
File: src/i18n/i18n-config.ts
================
// src/i18n/i18n-config.ts
export const languages = {
    en: 'English',
    pl: 'Polski'
  } as const;
  
  export const defaultLang = 'en';
  export const showDefaultLang = false;
  
  export type SupportedLanguages = keyof typeof languages;

================
File: src/i18n/utils.ts
================
// src/i18n/utils.ts
import { getCollection } from 'astro:content';
import { languages, defaultLang, showDefaultLang, type SupportedLanguages } from './i18n-config';

let cachedUI: Record<string, any> | null = null;

export async function getUI(lang: SupportedLanguages = defaultLang) {
  if (!cachedUI) {
    const uiCollection = await getCollection('ui');
    cachedUI = Object.fromEntries(
      uiCollection.map(entry => [entry.id, entry.data])
    );
  }
  return cachedUI[lang] || cachedUI[defaultLang];
}

export function getLocaleFromUrl(url: URL) {
  const [, lang] = url.pathname.split('/');
  if (lang in languages) return lang as SupportedLanguages;
  return defaultLang;
}

export async function useTranslations(lang: SupportedLanguages) {
  const ui = await getUI(lang);
  return function t(key: string) {
    return key.split('.').reduce((obj, key) => obj?.[key], ui) || '';
  }
}

export function getLocalizedURL(currentPath: string, locale: string, defaultLang: string) {
  // Remove the current locale from the path if it exists
  const pathWithoutLocale = currentPath.replace(/^\/[^/]+\/?/, '');

  // Don't add locale prefix for default language
  if (locale === defaultLang) {
    return pathWithoutLocale || '/';
  }

  // Add the new locale prefix
  return `/${locale}${pathWithoutLocale ? `/${pathWithoutLocale}` : ''}`;
}

export { languages, defaultLang, showDefaultLang };

================
File: src/layouts/BaseLayout.astro
================
---
// src/layouts/BaseLayout.astro
import Analytics from "@vercel/analytics/astro";
import Footer from "../components/astro/Footer.astro";
import Header from "../components/astro/Header.astro";
import SEO from "../components/astro/seo.astro";
import {
  getLocaleFromUrl,
  getLocalizedURL,
  useTranslations,
  languages,
  defaultLang,
} from "../i18n/utils";

interface Props {
  title: string;
  description?: string;
  image?: string;
  type?: string;
}

const { title, description, image, type } = Astro.props;

const currentLocale = getLocaleFromUrl(Astro.url);
const currentPath = Astro.url.pathname;
const t = await useTranslations(currentLocale);

// Get the site URL from Astro.site or fallback to current URL origin
const siteUrl = Astro.site?.origin || Astro.url.origin;

// Define type for alternateUrls
interface AlternateUrls {
  [key: string]: string;
  "x-default": string;
  en: string;
  pl: string;
}

// First, create the language URLs
const baseAlternateUrls = Object.keys(languages).reduce<Record<string, string>>(
  (acc, locale) => {
    const path = getLocalizedURL(currentPath, locale, defaultLang);
    const url = new URL(path, siteUrl).toString();
    return { ...acc, [locale]: url };
  },
  {}
);

// Then create the complete alternateUrls object with proper typing
const alternateUrlsWithDefault: AlternateUrls = {
  ...baseAlternateUrls,
  "x-default": baseAlternateUrls["en"],
  en: baseAlternateUrls["en"],
  pl: baseAlternateUrls["pl"],
};
---

<!doctype html>
<html lang={currentLocale}>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />

    <SEO
      title={title}
      description={description || t("meta.description")}
      image={image}
      type={type}
      currentLocale={currentLocale}
      alternateUrls={alternateUrlsWithDefault}
    />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body class="bg-black text-white font-mono">
    <div class="flex flex-col min-h-screen">
      <Header />
      <main class="flex-grow mx-auto max-w-3xl px-8 py-16">
        <slot />
      </main>
      <Footer />
      <Analytics />
    </div>
  </body>
</html>

================
File: src/pages/[lang]/tools/[...slug].astro
================
---
// src/pages/[lang]/tools/[...slug].astro
import { type CollectionEntry, getCollection, render } from "astro:content";
import { Image } from "astro:assets";
import BaseLayout from "@/layouts/BaseLayout.astro";
import { getLocaleFromUrl, useTranslations } from "@/i18n/utils";
import type { SupportedLanguages } from "@/i18n/i18n-config";

// Add prerender flag
export const prerender = true;

export async function getStaticPaths() {
  const tools = await getCollection("tools");

  return tools.flatMap((tool) => {
    const slug = tool.id.split("/").pop();
    return [
      {
        params: { lang: "en", slug },
        props: { tool, lang: "en" as SupportedLanguages },
      },
      {
        params: { lang: "pl", slug },
        props: { tool, lang: "pl" as SupportedLanguages },
      },
    ];
  });
}

const { tool, lang } = Astro.props;
const t = await useTranslations(lang as SupportedLanguages);

// Get localized content
const localizedContent = tool.data.i18n[lang];

// Ensure localized content exists
if (!localizedContent) {
  throw new Error(`Missing localized content for language: ${lang}`);
}

// Render MDX content
const { Content } = await render(tool);

// Format date for display
const formattedDate = new Intl.DateTimeFormat(lang, {
  year: "numeric",
  month: "long",
  day: "numeric",
}).format(tool.data.lastUpdated);

// Tailwind classes
const classes = {
  header: "mb-8 pb-8 border-b border-gray-700",
  logo: "w-24 h-24 flex-shrink-0",
  logoImg: "w-full h-full object-contain rounded-lg bg-gray-800 p-2",
  logoPlaceholder:
    "w-full h-full bg-gray-800 rounded-lg flex items-center justify-center",
  title: "text-4xl font-bold mb-4",
  description: "text-xl text-gray-400 mb-4",
  badges: "flex flex-wrap gap-3",
  badge: "px-3 py-1 bg-gray-800 rounded-full text-sm",
  links: "flex gap-4 mt-6",
  primaryLink:
    "px-4 py-2 bg-white text-black font-bold rounded hover:bg-gray-200 transition-colors",
  secondaryLink:
    "px-4 py-2 border border-gray-600 rounded hover:border-gray-400 transition-colors",
  features: "mb-8",
  featuresList: "grid gap-3",
  featureItem: "flex items-start gap-2",
  content: "prose prose-invert max-w-none",
  footer: "mt-12 pt-8 border-t border-gray-700 text-sm text-gray-400",
};
---

<BaseLayout
  title={`${localizedContent.title} - ${t("tools.title")}`}
  description={localizedContent.description}
>
  <article class="max-w-4xl mx-auto px-4">
    <header class={classes.header}>
      <div class="flex items-start gap-6">
        {/* Tool Logo */}
        <div class={classes.logo}>
          {
            tool.data.logo ? (
              <Image
                src={tool.data.logo}
                alt={`${localizedContent.title} logo`}
                width={96}
                height={96}
                class={classes.logoImg}
              />
            ) : (
              <div class={classes.logoPlaceholder}>
                <span class="text-xs text-gray-400">No logo</span>
              </div>
            )
          }
        </div>

        {/* Tool Title and Description */}
        <div class="flex-grow">
          <h1 class={classes.title}>{localizedContent.title}</h1>
          <p class={classes.description}>{localizedContent.description}</p>

          {/* Tool Metadata Badges */}
          <div class={classes.badges}>
            <span class={classes.badge}>
              {t(`tools.status.${tool.data.status}`)}
            </span>
            <span class={classes.badge}>
              {t(`tools.categories.${tool.data.category}`)}
            </span>
            {
              tool.data.metadata?.pricing && (
                <span class={classes.badge}>
                  {t(`tools.pricing.${tool.data.metadata.pricing}`)}
                </span>
              )
            }
          </div>
        </div>
      </div>

      {/* Tool Links */}
      <div class={classes.links}>
        <a
          href={tool.data.website}
          target="_blank"
          rel="noopener noreferrer"
          class={classes.primaryLink}
        >
          {t("tools.visit_website")}
        </a>
        {
          tool.data.github && (
            <a
              href={tool.data.github}
              target="_blank"
              rel="noopener noreferrer"
              class={classes.secondaryLink}
            >
              GitHub
            </a>
          )
        }
      </div>
    </header>

    {/* Tool Features */}
    {
      localizedContent.features.length > 0 && (
        <section class={classes.features}>
          <h2 class="text-2xl font-bold mb-4">{t("tools.key_features")}</h2>
          <ul class={classes.featuresList}>
            {localizedContent.features.map((feature) => (
              <li class={classes.featureItem}>
                <span class="text-gray-400 mt-1">•</span>
                <span>{feature}</span>
              </li>
            ))}
          </ul>
        </section>
      )
    }

    {/* MDX Content */}
    <section class={classes.content}>
      <Content />
    </section>

    {/* Tool Footer */}
    <footer class={classes.footer}>
      <p>{t("tools.last_updated")}: {formattedDate}</p>
    </footer>
  </article>
</BaseLayout>

================
File: src/pages/[lang]/tools/index.astro
================
---
// src/pages/[lang]/tools/index.astro
import { type CollectionEntry, getCollection } from "astro:content";
import BaseLayout from "@/layouts/BaseLayout.astro";
import ToolCard from "@/components/tools/ToolCard.astro";
import { getLocaleFromUrl, useTranslations } from "@/i18n/utils";

// Get current language and translations

const lang = getLocaleFromUrl(Astro.url) as "en" | "pl";

const t = await useTranslations(lang);

// Fetch all tools with error handling
let tools: CollectionEntry<"tools">[] = [];
try {
  tools = await getCollection("tools");
} catch (error) {
  console.error("Error fetching tools:", error);
}

// Tailwind classes
const classes = {
  container: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12",
  title: "text-4xl font-bold mb-8",
  toolsGrid: "grid gap-6 md:grid-cols-2 lg:grid-cols-3",
  noTools: "text-gray-400 italic",
};
---

<BaseLayout
  title={t("tools.title")}
  description={t("tools.description")}
  type="website"
>
  <main class={classes.container}>
    <h1 class={classes.title}>{t("tools.title")}</h1>

    {/* Simple tools grid */}
    {
      tools.length > 0 ? (
        <div class={classes.toolsGrid}>
          {tools.map((tool) => (
            <ToolCard tool={tool} lang={lang} />
          ))}
        </div>
      ) : (
        <p class={classes.noTools}>{t("tools.no_tools_found")}</p>
      )
    }
  </main>
</BaseLayout>

================
File: src/pages/api/subscribe.ts
================
// src/pages/api/subscribe.ts
import type { APIRoute } from 'astro';

export const prerender = false;

function isValidEmail(email: string): boolean {
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  return email.length <= 320 && emailRegex.test(email);
}

export const POST: APIRoute = async ({ request }) => {
  const headers = {
    'Content-Type': 'application/json'
  };

  try {
    // Validate environment variables
    const BEEHIIV_API_KEY = import.meta.env.BEEHIIV_API_KEY;
    const BEEHIIV_PUBLICATION_ID = import.meta.env.BEEHIIV_PUBLICATION_ID;

    if (!BEEHIIV_API_KEY || !BEEHIIV_PUBLICATION_ID) {
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Server configuration error'
        }),
        { status: 500, headers }
      );
    }

    // Parse and validate request
    const body = await request.json();
    const email = body.email?.toString().toLowerCase().trim();

    if (!email || !isValidEmail(email)) {
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Please provide a valid email address'
        }),
        { status: 400, headers }
      );
    }

    // Call Beehiiv API
    const response = await fetch(
      `https://api.beehiiv.com/v2/publications/${BEEHIIV_PUBLICATION_ID}/subscriptions`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${BEEHIIV_API_KEY}`,
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          email,
          reactivate_existing: true,
          send_welcome_email: true,
          utm_source: 'website',
          double_opt_in: false
        })
      }
    );

    const responseData = await response.json();

    if (!response.ok) {
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Failed to subscribe',
          details: responseData
        }),
        { status: response.status, headers }
      );
    }

    return new Response(
      JSON.stringify({
        success: true,
        message: 'Successfully subscribed!'
      }),
      { status: 200, headers }
    );

  } catch (error) {
    console.error('Subscription error:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: 'An unexpected error occurred'
      }),
      { status: 500, headers }
    );
  }
};

================
File: src/pages/pl/index.astro
================
---
import BaseLayout from "../../layouts/BaseLayout.astro";
import { getCollection } from "astro:content";

const homeEntries = await getCollection("home");
const content = homeEntries.find((entry) => entry.id.startsWith("pl"))?.data;

if (!content) {
  throw new Error(`No content found for locale: pl`);
}

const styles = {
  section: "mt-16 pt-8 border-t border-gray-600",
  contentBlock:
    "mb-8 transform transition-transform duration-300 ease-in-out hover:translate-x-2",
  title: "text-xl font-bold mb-2",
  description: "text-gray-400",
  cta: "inline-block px-6 py-3 bg-white text-black font-bold transition-colors duration-300 ease-in-out hover:bg-gray-400 hover:text-white",
};
---

<BaseLayout title={`Web3Yoda - ${content.hero.title}`}>
  <div class="container">
    <header>
      <h1 class="text-4xl font-bold mb-2">{content.hero.title}</h1>
      <p class="text-gray-400 mb-8 text-lg">{content.hero.subtitle}</p>
    </header>

    <section class={styles.section}>
      <h2 class="text-2xl font-bold mb-8">{content.consultations.title}</h2>
      {
        content.consultations.items.map((item) => (
          <div class={styles.contentBlock}>
            <h3 class={styles.title}>{item.title}</h3>
            <p class={styles.description}>{item.description}</p>
          </div>
        ))
      }
    </section>

    <section class={styles.section}>
      <h2 class="text-2xl font-bold mb-8">{content.services.title}</h2>
      {
        content.services.items.map((item) => (
          <div class={styles.contentBlock}>
            <h3 class={styles.title}>{item.title}</h3>
            <p class={styles.description}>{item.description}</p>
          </div>
        ))
      }
    </section>

    <section class={styles.section}>
      <h2 class="text-2xl font-bold mb-8">{content.discovery.title}</h2>
      <div class={styles.contentBlock}>
        <p class={`${styles.description} mb-4`}>
          {content.discovery.description}
        </p>
        <a href="https://cal.com/web3yoda/15min" class={styles.cta}>
          {content.discovery.cta}
        </a>
      </div>
    </section>

    <section class={styles.section}>
      <h2 class="text-2xl font-bold mb-8">{content.benefits.title}</h2>
      <div class="space-y-12">
        {
          content.benefits.items.map((benefit) => (
            <div class={styles.contentBlock}>
              <h3 class={styles.title}>{benefit.title}</h3>
              <p class={styles.description}>{benefit.description}</p>
            </div>
          ))
        }
      </div>
    </section>
  </div>
</BaseLayout>

================
File: src/pages/debug-routes.astro
================
---
import { getCollection } from "astro:content";
import {
  getLocalizedURL,
  languages,
  defaultLang,
  showDefaultLang,
} from "../i18n/utils"; // Add showDefaultLang import

// Get current URL info
const currentUrl = Astro.url;
const pathname = currentUrl.pathname;

const tools = await getCollection("tools");

// Test various route combinations
const testPaths = ["/tools", "/tools/unisat", "/en/tools", "/en/tools/unisat"];

const routeInfo = testPaths.map((path) => ({
  path,
  localizedURLs: Object.keys(languages).map((lang) => ({
    lang,
    url: getLocalizedURL(path, lang, defaultLang),
  })),
}));

console.log("=== Debug: Current Request ===");
console.log("Current pathname:", pathname);
console.log("Default language:", defaultLang);
console.log("Available languages:", languages);

console.log("=== Debug: Route Generation ===");
console.log("Route Info:", JSON.stringify(routeInfo, null, 2));
---

<h1>Route Debugging Information</h1>

<h2>Current Request</h2>
<pre>
Pathname: {pathname}
Default Language: {defaultLang}
Available Languages: {JSON.stringify(languages, null, 2)}
</pre>

<h2>i18n Configuration</h2>
<pre>
Default Language: {defaultLang}
Show Default Lang Prefix: {showDefaultLang}
</pre>

<h2>Test Routes</h2>
{
  routeInfo.map((info) => (
    <div style="margin-bottom: 2rem; padding: 1rem; border: 1px solid #ccc;">
      <h3>Original Path: {info.path}</h3>
      <ul>
        {info.localizedURLs.map(({ lang, url }) => (
          <li>
            {lang}: {url}
            <a href={url} style="margin-left: 1rem;">
              (Test Link)
            </a>
          </li>
        ))}
      </ul>
    </div>
  ))
}

<h2>Available Tool Routes</h2>
<ul>
  {
    tools.map((tool) => {
      const slug = tool.id.split("/").pop();
      return (
        <li>
          <strong>{tool.id}</strong>
          <ul>
            <li>
              EN: /tools/{slug} <a href={`/tools/${slug}`}>(Test)</a>
            </li>
            <li>
              EN with prefix: /en/tools/{slug}{" "}
              <a href={`/en/tools/${slug}`}>(Test)</a>
            </li>
            <li>
              PL: /pl/tools/{slug} <a href={`/pl/tools/${slug}`}>(Test)</a>
            </li>
          </ul>
        </li>
      );
    })
  }
</ul>

================
File: src/pages/debug.astro
================
---
import { getCollection, type CollectionEntry } from "astro:content";
import type { CollectionKey } from "astro:content";

const homeContent = await getCollection("home" as CollectionKey);
console.log("Collection contents:", homeContent);

const content = homeContent.find((entry) => entry.id === "en.json")?.data;
console.log("Found content:", content);
---

<pre>
  Home Collection: {JSON.stringify(homeContent, null, 2)}
  Found Content: {JSON.stringify(content, null, 2)}
</pre>

================
File: src/pages/index.astro
================
---
import BaseLayout from "../layouts/BaseLayout.astro";
import { getCollection } from "astro:content";

const homeEntries = await getCollection("home");
const content = homeEntries.find((entry) => entry.id.startsWith("en"))?.data;

if (!content) {
  throw new Error(`No content found for locale: en`);
}

const styles = {
  section: "mt-16 pt-8 border-t border-gray-600",
  contentBlock:
    "mb-8 transform transition-transform duration-300 ease-in-out hover:translate-x-2",
  title: "text-xl font-bold mb-2",
  description: "text-gray-400",
  cta: "inline-block px-6 py-3 bg-white text-black font-bold transition-colors duration-300 ease-in-out hover:bg-gray-400 hover:text-white",
};
---

<BaseLayout title={`Web3Yoda - ${content.hero.title}`}>
  <div class="container">
    <header>
      <h1 class="text-4xl font-bold mb-2">{content.hero.title}</h1>
      <p class="text-gray-400 mb-8">{content.hero.subtitle}</p>
    </header>

    <section class={styles.section}>
      <h2 class="text-2xl font-bold mb-8">{content.consultations.title}</h2>
      {
        content.consultations.items.map((item) => (
          <div class={styles.contentBlock}>
            <h3 class={styles.title}>{item.title}</h3>
            <p class={styles.description}>{item.description}</p>
          </div>
        ))
      }
    </section>

    <section class={styles.section}>
      <h2 class="text-2xl font-bold mb-8">{content.services.title}</h2>
      {
        content.services.items.map((item) => (
          <div class={styles.contentBlock}>
            <h3 class={styles.title}>{item.title}</h3>
            <p class={styles.description}>{item.description}</p>
          </div>
        ))
      }
    </section>

    <section class={styles.section}>
      <h2 class="text-2xl font-bold mb-8">{content.discovery.title}</h2>
      <div class={styles.contentBlock}>
        <p class={`${styles.description} mb-4`}>
          {content.discovery.description}
        </p>
        <a href="https://cal.com/web3yoda/15min" class={styles.cta}>
          {content.discovery.cta}
        </a>
      </div>
    </section>

    <section class={styles.section}>
      <h2 class="text-2xl font-bold mb-8">{content.benefits.title}</h2>
      <div class="space-y-12">
        {
          content.benefits.items.map((benefit) => (
            <div class={styles.contentBlock}>
              <h3 class={styles.title}>{benefit.title}</h3>
              <p class={styles.description}>{benefit.description}</p>
            </div>
          ))
        }
      </div>
    </section>
  </div>
</BaseLayout>

================
File: .gitignore
================
# build output
dist/
# generated types
.astro/
.vercel

# dependencies
node_modules/

# logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*


# environment variables
.env
.env.production

# macOS-specific files
.DS_Store

# jetbrains setting folder
.idea/
repopack-output.txt

================
File: astro-mentor-prompt.md
================
# Astro Development Mentor Role

You are now an experienced senior developer and Astro expert who will guide me in implementing a Web3 tools directory on web3yoda.xyz. Your role combines technical expertise with mentorship qualities.

## Core Responsibilities

1. Guide Implementation
- Reference the established POC delivery plan
- Follow Astro 5's official documentation and best practices
- Maintain existing project structure and patterns
- Focus on shipping production-ready code

2. Educational Approach
- Explain concepts when introducing them
- Point out common pitfalls and best practices
- Share relevant documentation links
- Break down complex tasks into manageable steps

3. Reference Sources
- Astro documentation (via brave-search)
- MDX documentation (via brave-search)
- Content Collections guide (via brave-search)

## Development Principles

1. Code Quality
- Follow Astro's recommended patterns
- Maintain type safety
- Ensure proper error handling
- Write maintainable code

2. Simplicity First
- Avoid unnecessary abstractions
- No premature optimization
- Keep solutions straightforward
- Only add complexity when justified

3. Focus on Deliverables
- Stick to the POC requirements
- Don't introduce unnecessary features
- Maintain existing project patterns
- Prioritize shipping working code

## Interaction Guidelines

1. When Asked for Help
- First understand the current task
- Check existing codebase
- Reference official documentation
- Provide clear, actionable guidance

2. When Explaining
- Use clear, concise language
- Provide context when needed
- Include code examples
- Reference official docs

3. When Reviewing Code
- Check against best practices
- Verify type safety
- Ensure maintainability
- Suggest improvements

## Development Process

1. For Each Task
- Understand requirements
- Check existing implementation
- Reference documentation
- Provide step-by-step guidance

2. When Adding Features
- Verify necessity
- Check integration points
- Follow existing patterns
- Test thoroughly

3. When Debugging
- Understand the issue
- Check documentation
- Provide clear solutions
- Explain the fix

## Response Format

For each interaction:

1. Task Understanding
- Confirm what needs to be done
- Reference relevant plan section
- Identify dependencies

2. Implementation Guidance
- Step-by-step instructions
- Code examples
- Documentation references

3. Learning Opportunities
- Explain key concepts
- Point out best practices
- Share helpful resources

## Error Prevention

Always:
- Verify type safety
- Check for edge cases
- Ensure error handling
- Maintain consistent patterns

Never:
- Add unnecessary complexity
- Introduce new patterns without reason
- Skip error handling
- Ignore type safety

## Key Focus Areas

1. Content Collections
- Proper schema definition
- Type safety
- Content organization
- Query optimization

2. i18n Implementation
- Follow existing patterns
- Maintain type safety
- Ensure consistent routing
- Handle translations properly

3. Component Design
- Keep it simple
- Follow existing patterns
- Ensure reusability
- Maintain type safety

Remember: Your goal is to help ship a working POC while teaching best practices, not to showcase advanced features or unnecessary complexity.

================
File: astro.config.mjs
================
// astro.config.mjs
import { defineConfig } from 'astro/config';
import react from '@astrojs/react';
import tailwind from '@astrojs/tailwind';
import vercel from '@astrojs/vercel/serverless';
import mdx from '@astrojs/mdx';

export default defineConfig({
  output: 'server',
  site: 'https://web3yoda.xyz',
  integrations: [react(), tailwind(), mdx()],
  adapter: vercel({
    analytics: true // Enable Vercel Analytics
  }),

  i18n: {
    defaultLocale: 'en',
    locales: ['en', 'pl'],
    routes: {
      pl: {
        prefix: 'pl'
      }
    },
    routing: {
      prefixDefaultLocale: false
    }
  },
  compilerOptions: {
    "types": ["astro/client"]
  },
  image: {
    service: {
      entrypoint: 'astro/assets/services/sharp',
      config: {
        limitInputPixels: 0,
        limitOutputPixels: 0,
        maximum: 30000,
      }
    }
  },
  vite: {
    envPrefix: [
      'PUBLIC_',
      'BEEHIIV_'
    ]
  },
  ssr: {
      noExternal: ['react', 'react-dom']
    },
    optimizeDeps: {
      include: ['react', 'react-dom']
    }
});

================
File: package.json
================
{
  "name": "web3yoda",
  "type": "module",
  "version": "0.0.1",
  "scripts": {
    "dev": "astro dev",
    "start": "astro dev",
    "build": "astro check && astro build",
    "preview": "astro preview",
    "astro": "astro"
  },
  "dependencies": {
    "@astrojs/check": "^0.9.4",
    "@astrojs/mdx": "^4.0.5",
    "@astrojs/node": "^9.0.0",
    "@astrojs/react": "^4.1.2",
    "@astrojs/tailwind": "^5.1.4",
    "@astrojs/vercel": "^8.0.1",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@vercel/analytics": "^1.4.1",
    "astro": "^5.1.3",
    "lucide-react": "^0.453.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "tailwindcss": "^3.4.14",
    "typescript": "^5.6.3"
  },
  "devDependencies": {
    "@tailwindcss/typography": "^0.5.15"
  }
}

================
File: README.md
================
# Astro Starter Kit: Minimal

```sh
npm create astro@latest -- --template minimal
```

[![Open in StackBlitz](https://developer.stackblitz.com/img/open_in_stackblitz.svg)](https://stackblitz.com/github/withastro/astro/tree/latest/examples/minimal)
[![Open with CodeSandbox](https://assets.codesandbox.io/github/button-edit-lime.svg)](https://codesandbox.io/p/sandbox/github/withastro/astro/tree/latest/examples/minimal)
[![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/withastro/astro?devcontainer_path=.devcontainer/minimal/devcontainer.json)

> 🧑‍🚀 **Seasoned astronaut?** Delete this file. Have fun!

## 🚀 Project Structure

Inside of your Astro project, you'll see the following folders and files:

```text
/
├── public/
├── src/
│   └── pages/
│       └── index.astro
└── package.json
```

Astro looks for `.astro` or `.md` files in the `src/pages/` directory. Each page is exposed as a route based on its file name.

There's nothing special about `src/components/`, but that's where we like to put any Astro/React/Vue/Svelte/Preact components.

Any static assets, like images, can be placed in the `public/` directory.

## 🧞 Commands

All commands are run from the root of the project, from a terminal:

| Command                   | Action                                           |
| :------------------------ | :----------------------------------------------- |
| `npm install`             | Installs dependencies                            |
| `npm run dev`             | Starts local dev server at `localhost:4321`      |
| `npm run build`           | Build your production site to `./dist/`          |
| `npm run preview`         | Preview your build locally, before deploying     |
| `npm run astro ...`       | Run CLI commands like `astro add`, `astro check` |
| `npm run astro -- --help` | Get help using the Astro CLI                     |

## 👀 Want to learn more?

Feel free to check [our documentation](https://docs.astro.build) or jump into our [Discord server](https://astro.build/chat).

================
File: tailwind.config.mjs
================
/** @type {import('tailwindcss').Config} */
export default {
	content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],
	theme: {
	  extend: {
		fontFamily: {
		  mono: ['Space Mono', 'monospace'],
		},
		colors: {
		  primary: '#ffffff',
		  background: '#000000',
		  accent: '#666666',
		},
		keyframes: {
		  'slide-up': {
			'0%': { transform: 'translateY(100%)', opacity: '0' },
			'100%': { transform: 'translateY(0)', opacity: '1' },
		  }
		},
		animation: {
		  'slide-up': 'slide-up 0.3s ease-out'
		}
	  },
	},
	plugins: [],
  }

================
File: tsconfig.json
================
{
  "extends": "astro/tsconfigs/base",
  "include": [
    ".astro/types.d.ts",
    "**/*"
  ],
  "exclude": [
    "dist"
  ],
  "compilerOptions": {
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "jsxImportSource": "react",
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "src/*"
      ]
    }
  }
}

================
File: vercel.json
================
{
    "cleanUrls": true,
    "trailingSlash": false,
    "headers": [
      {
        "source": "/(.*)",
        "headers": [
          {
            "key": "X-Content-Type-Options",
            "value": "nosniff"
          },
          {
            "key": "X-Frame-Options",
            "value": "DENY"
          },
          {
            "key": "X-XSS-Protection",
            "value": "1; mode=block"
          }
        ]
      }
    ]
  }
